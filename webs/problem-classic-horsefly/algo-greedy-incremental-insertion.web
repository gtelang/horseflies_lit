\section{Algorithm: Greedy---Incremental Insertion}
\subsection*{Algorithmic Overview}
\newchunk The greedy nearest neighbor heuristic described in \autoref{sec:greedy-nn} gives an $O(\log n)$ 
          approximation for $n$ sites in the plane. However, there exists an alternative greedy incremental 
          insertion algorithm for the TSP that yields a 2-approximation. Similar to the greedy-nn algorithm 
          we can generalize the greedy-incremental approach to the collinear-horseflies setting 
          (cf: \autoref{fig:collinear-horseflies}). 
\newchunk In this approach, we maintain a list of visited sites $V$ (along with the order of visitation 
          $\mathcal{O}$) and the unvisited sites $U$. For the given collinear-horsefly tour serving $V$ 
          pick a site $s$ from $U$ along with a position in $\mathcal{O}$ (calling the resulting ordering  
          $\mathcal{O^{'}}$  ) that minimizes the cost of the horsefly tour serving the sites $V \cup \{s\}$ 
          in the order $\mathcal{O^{'}}$. 

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{../webs/docs/incremental_insertion_frames.eps}
\end{figure}

The figure above depicts the incremental insertion process for the case of 4 sites and $\varphi=3$. The 
implementation of this algorithm for collinear-horseflies raises several interesting non-trivial 
data-structural questions in their own right: how to quickly find the site from $U$ to 
insert into $V$, and keep track the changing length of the horsefly tour. Note that inserting a site 
causes the length of the tour of the truck to change, for all the sites after $s$. 
 
\subsection*{Algorithmic Details}
\newchunk The implementation of the algorithm is ``parametrized'' over various strategies for insertion. 
i.e. we treat each insertion policy as a black-box argument to the function.
 
Efficient policies for detecting the exact or approximate point for cheapest insertion will be 
described in \autoref{subsec:insertion-policies}.  We also implement a ``naive'' policy as a way 
benchmark the quality and speed of implementation of future insertion policies. 

@D Algorithms for classic horsefly @{
@<Define auxiliary helper functions@>
@<Define various insertion policy classes@>
def algo_greedy_incremental_insertion(sites, inithorseposn, phi,
                                      insertion_policy_name = "naive",
                                      log_level             = None,
                                      write_io              = True, 
                                      post_optimizer        = None):
      @<Set log, algo-state and input-output files config@>
      @<Set insertion policy class for current run@>

      while insertion_policy.unvisited_sites_idxs: 
         @<Use insertion policy to find the cheapest site to insert into current tour@>
         @<Write algorithm's current state to file@>

      @<Write input and output to file@>
      @<Return horsefly tour, along with additional information@>
@| algo_greedy_incremental_insertion @}


\newchunk Note that for each run of the algorithm, we create a dedicated directory and 
use a corresponding log file  in that directory. It will typically containe detailed 
information on the progress of the algorithm and the steps executed. 

For algorithm analysis, and verification of correctness,on the other hand, we will 
typically  be interested in the states of the data-structures at the end of 
the while loop; each such state will be written out as a YAML file. Such files can 
be useful for animating the progress of the algorithm. 

Finally, just before returning the answer, we write the input and output 
to a separate YAML file. All in all, there are three ``types'' of output files
within each directory that corresponds to an algorithm's run: 
\underline{a log file}, \underline{algorithm states files}, and finally 
an \underline{input-output file}. 

@D Set log, algo-state and input-output files config @{  
import sys, logging, datetime, os, errno

algo_name     = 'algo-greedy-incremental-insertion'
time_stamp    = datetime.datetime.now().strftime('Day-%Y-%m-%d_ClockTime-%H:%M:%S')
dir_name      = algo_name + '---' + time_stamp
log_file_name = dir_name + '/' + 'run.log'
io_file_name  = 'input_and_output.yml'

# Create directory for writing data-files and logs to for 
# current run of this algorithm
try:
    os.makedirs(dir_name)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

logging.basicConfig( filename = log_file_name,
                     level    = logging.DEBUG,
                     format   = '%(asctime)s: %(levelname)s: %(message)s',
                     filemode = 'w' )
logger = logging.getLogger()
logger.info("Started running greedy_incremental_insertion for classic horsefly")

algo_state_counter = 0 
@| io_file_name, logger @}


\newchunk This fragment merely sets the variable \verb|insertion_policy| to 
the appropriate function. This will later help us in studying the speed of 
the algorithm and quality of the solution for various insertion policies 
during the experimental analysis. 

@D Set insertion policy class for current run @{
if insertion_policy_name == "naive":
     insertion_policy = PolicyNaive(sites, inithorseposn, phi)
else: 
     print insertion_policy_name
     sys.exit("Unknown insertion policy: ")

logger.debug("Finished setting insertion policy: " + insertion_policy_name)
@| @}


\newchunk Note that while defining the body of the algorithm, we treat the insertion policy 
(whose name has already been passed as an string argument) as a kind of black-box, since all 
policy classes have the same interface. The detailed implementation for the various 
insertion policies are given later. 

@D Use insertion policy to find the cheapest site to insert into current tour 
@{insertion_policy.insert_another_unvisited_site()
logger.debug("Inserted another unvisited site")
@| @}

\newchunk 
@D Write algorithm's current state to file @{   
import yaml
algo_state_file_name = 'algo_state_'                    + \
                       str(algo_state_counter).zfill(5) + \
                       '.yml'

data = {'insertion_policy_name' : insertion_policy_name                       ,
        'unvisited_sites'       : [insertion_policy.sites[u] \
                                       for u in insertion_policy.unvisited_sites_idxs], 
        'visited_sites'         : insertion_policy.visited_sites                    , 
        'horse_tour'            : insertion_policy.horse_tour }

with open(dir_name + '/' + algo_state_file_name, 'w') as outfile:
     yaml.dump( data   , \
                outfile, \
                default_flow_style = False)
algo_state_counter = algo_state_counter + 1
logger.debug("Dumped algorithm state to " + algo_state_file_name)
@| @}

\newchunk The answer is reported in the form of a YAML file, which lists the input sites 
in the order of visitation computed by the algorithm and gives the tour of the horse. 
Note that the number of points on the horse's tour is 1 more than the number of given sites. 

@D Write input and output to file @{
# ASSERT: `inithorseposn` is included as first point of the tour
assert(len(insertion_policy.horse_tour) == len(insertion_policy.visited_sites) + 1) 

# ASSERT: All sites have been visited. Simple sanity check 
assert(len(insertion_policy.sites)   == len(insertion_policy.visited_sites)) 


data = {'insertion_policy_name' : insertion_policy_name   ,
        'visited_sites'  : insertion_policy.visited_sites , 
        'horse_tour'     : insertion_policy.horse_tour    , 
        'phi'            : insertion_policy.phi           , 
        'inithorseposn'  : insertion_policy.inithorseposn}

with open(dir_name + '/' + io_file_name, 'w') as outfile:
     yaml.dump( data, \
                outfile, \
                default_flow_style=False)
logger.debug("Dumped input and output to " + io_file_name)

# Read back the data for a quick sanity-check
# of result before returning answer. 
import utils_algo
with open(dir_name + '/' + io_file_name, 'r') as stream:
     data_loaded = yaml.load(stream)
print '\n--------------------------------------------'
print "INITIAL HORSEPOSITION "
print data_loaded['inithorseposn']
print '\n--------------------------------------------'
print "SPEED RATIO"
print data_loaded['phi']
print '\n--------------------------------------------'
print "HORSE TOUR"
utils_algo.print_list(data_loaded['horse_tour'])
print '\n--------------------------------------------'
print "VISITED SITES ARE"
utils_algo.print_list(data_loaded['visited_sites'])
print '\n--------------------------------------------'
logger.debug("Reading back data from files printed out for sanity-check of data-written")
@| @}

\newchunk 
@D Return horsefly tour, along with additional information@{
logger.debug("Returning answer")
horse_waiting_times = np.zeros(len(sites))
return {'tour_points'                : insertion_policy.horse_tour[1:],
        'horse_waiting_times'        : horse_waiting_times, 
        'site_ordering'              : insertion_policy.visited_sites,
        'tour_length_with_waiting_time_included': \
                                       tour_length_with_waiting_time_included(\
                                                    insertion_policy.horse_tour[1:], \
                                                    horse_waiting_times, \
                                                    inithorseposn)}
@| @}

\newchunk We now define some of the functions that were referred to in the above chunks. 
Given the intial position of the truck and drone, and a list of sites, we need to compute 
the collinear horsefly tour length for the given ordering. This is the function that is 
used in every policy class while deciding which is the cheapest unvisited site to insert 
into the current ordering of visited sites. 

Note that the order in which sites are passed to this function matters. It 
assumes that you want to compute the collinear horseflies tour length for the 
sites \textit{in the given order.} 

For this, we use the formula for computing the rendezvous point and  

\begin{center}
\missingfigure[figwidth=6cm]{Sigle site analytic}
\end{center}

@D Define auxiliary helper functions @{
def single_site_solution(site, horseposn, phi):

     h = np.asarray(horseposn)
     s = np.asarray(site)
     
     hs_mag  = 1.0/np.linalg.norm(s-h) 
     hs_unit = 1.0/hs_mag * (s-h)
     
     r      = h +  2*hs_mag/(1+phi) * hs_unit # Rendezvous point
     hr_mag = np.linalg.norm(r-h)

     return (tuple(r), hr_mag) 
@| single_site_solution @}

With that the tour length functions for collinear horseflies can be implemented as 
an elementary instance of the fold pattern of functional programming. 
\footnote{Python has folds tucked away in some corner of its standard library. 
But I am not using it during the first hacky portion of this draft. Also Shane 
mentioned it has performance issues? Double-check this later!}

\begin{center}
\missingfigure[figwidth=6cm]{Figure for showing the length of tour in collinear horseflies}
\end{center}

@D Define auxiliary helper functions @{   
def compute_collinear_horseflies_tour_length(sites, horseposn, phi):

     if not sites: # No more sites, left to visit!
          return 0
     else:         # Some sites are still left on the itinerary

          (rendezvous_pt, horse_travel_length) = single_site_solution(sites[0], horseposn, phi )
          return horse_travel_length  + \
                 compute_collinear_horseflies_tour_length( sites[1:], rendezvous_pt, phi )
@| compute_collinear_horseflies_tour_length @}

\newchunk 
@d Define auxiliary helper functions @{   
def compute_collinear_horseflies_tour(sites, inithorseposn, phi):

      horseposn         = inithorseposn
      horse_tour_points = [inithorseposn]

      for site in sites:
          (rendezvous_pt, _) = single_site_solution(site, horseposn, phi )
            
          horse_tour_points.append(rendezvous_pt)
          horseposn = rendezvous_pt

      return horse_tour_points
@| compute_collinear_horseflies_tour @}



\section{Insertion Policies} 
\label{subsec:insertion-policies}

We have finished implemented the entire algorithm, except 
for the implementation of the various insertion policy classes. 

The main job of an insertion policy class is to keep track 
of the  unvisited sites,  the order of the visited sites and the 
horsefly tour itself. Every time, the method \verb|.get_next_site(...)| is called, it 
chooses an appropriate (i.e. cheapest) unvisited site to insert 
into the current ordering, and update the set of visited and unvisited sites
and details of the horsefly tour.  

To do this quickly it will typically need auxiliary data-structures whose specifics 
will depend on the details of the policy chosen. 

\subsection{Naive Insertion} \quad First, a naive implementation
  of the cheapest insertion heuristic, that will be useful in future
  benchmarking of running times and solution quality for implementations 
  that are quicker but make more sophisticated uses of data-structures. 

  In this policy for each unvisited site we first find the 
  position in the current tour, which after insertion into that position
  amongst the visited sites yields the smallest increase in the 
  collinear-horseflies tour-length. 

  Then we pick the unvisited site which yields the overall smallest 
  increase in tour-length and insert it into its computed position
  from its previous paragraph. 
     
  Clearly this implementation and has at least quadratic running time. 
  Later on, we will be investigating algorithms and data-structures 
  for speeding up this operation. 

  The hope is to be able to find a dynamic data-structure to perform this 
  insertion in logarithmic time. Variations on tools such as the well-separated pair 
  decomposition might help achieve this goal. Jon Bentley
  used kd-trees to perform the insertion in his experimental TSP
  paper, but he wasn't dealing with the shifting tour structure
  as we have in horseflies. Also he did not deal with the question 
  of finding an approximate point for insertion. These 

\newchunk Since the interface for all policy classes will be the same, it is 
best, if have a base class for such classes. Since the details of 
the interface may change, I'll probably do this later. For now, 
I'll just keep all the policy classes completely separate while 
keeping the interface of the constructors and methods the same. 
I'll refactor things later. 

The plan in that case should be to make an abstract class that 
has an abstract method called \texttt{insert\_unvisited\_site}
and three data-fields made from the base-constructor named \texttt{sites}, \texttt{inithorseposn}
and \texttt{phi}. Classes which inherit this abstract base class, will 
add their own local data-members and methods for keeping track of 
data for insertion. 

@D Define various insertion policy classes @{
class PolicyNaive:

    def __init__(self, sites, inithorseposn, phi):

         self.sites           = sites
         self.inithorseposn   = inithorseposn
         self.phi             = phi

         self.visited_sites        = []                # The actual list of visited sites (not indices)
         self.unvisited_sites_idxs = range(len(sites)) # This indexes into self.sites
         self.horse_tour           = [self.inithorseposn]         

    @<Methods for \verb|PolicyNaive| @>
@| self.sites, self.inithorseposn, self.visited_sites, self.horse_tour @}

\newchunk 
@D Methods for \verb|PolicyNaive| @{
def insert_another_unvisited_site(self):
 
     @<  Compute the length of the tour that currently services the visited sites @>    
     delta_increase_least_table = [] # tracking variable updated in for loop below

     for u in self.unvisited_sites_idxs:

         @< Set up tracking variables local to this iteration @>
         @< If \texttt{self.sites[u]} is chosen for insertion, find best insertion position and update \texttt{delta\_increase\_least\_table} @>  
                 
     @< Find the unvisited site which on insertion increases tour-length by the least amount  @>     
     @< Update states for \texttt{PolicyNaive} @> 
 
@| delta_increase_least_table @}


\newchunk 

@D  Compute the length of the tour that currently services the visited sites 
@{current_tour_length    = \
         compute_collinear_horseflies_tour_length(\
                    self.visited_sites,\
                    self.inithorseposn,\
                    self.phi) 
@| current_tour_length @}


\newchunk 
@D Set up tracking variables local to this iteration 
@{ibest                = 0
delta_increase_least = float("inf")
@| ibest, delta_increase_least @}

\newchunk 
@D If \texttt{self.sites[u]} is chosen for insertion, find best insertion position and update \texttt{delta\_increase\_least\_table} @{   
for i in range(len(self.sites)):
                    
            visited_sites_test = self.visited_sites[:i] +\
                                 [ self.sites[u] ]      +\
                                 self.visited_sites[i:]
                                      
            tour_length_on_insertion = \
                       compute_collinear_horseflies_tour_length(\
                                  visited_sites_test,\
                                  self.inithorseposn,\
                                  self.phi) 

            delta_increase = tour_length_on_insertion - current_tour_length                         
            assert(delta_increase >= 0)               

            if delta_increase < delta_increase_least:
                  delta_increase_least = delta_increase
                  ibest                = i                                              
                      
delta_increase_least_table.append({'unvisited_site_idx'      : u    , \
                                   'best_insertion_position' : ibest, \
                                   'delta_increase'          : delta_increase_least})
@| @}



\newchunk 
@D Find the unvisited site which on insertion increases tour-length by the least amount @{
best_table_entry = min(delta_increase_least_table, key = lambda x: x['delta_increase'])
         
unvisited_site_idx_for_insertion = best_table_entry['unvisited_site_idx']
insertion_position               = best_table_entry['best_insertion_position']
delta_increase                   = best_table_entry['delta_increase']
@| @}



\newchunk 
@D Update states for \texttt{PolicyNaive}  @{   
# Update visited and univisted sites info
self.visited_sites = self.visited_sites[:insertion_position]      +\
                     [self.sites[unvisited_site_idx_for_insertion]] +\
                     self.visited_sites[insertion_position:]
  
self.unvisited_sites_idxs = filter( lambda elt: elt != unvisited_site_idx_for_insertion, \
                                    self.unvisited_sites_idxs ) 

# Update the tour of the horse
self.horse_tour = compute_collinear_horseflies_tour(\
                           self.visited_sites,         \
                           self.inithorseposn, \
                           self.phi) 
@| @}

