%---------------------------------------------------------
% Every module is a chapter. Thus we keep the links 
% internal. Any labelling to other modules is done 
% manually. Nuweb provides the @s....@S sectioning 
% commands for this. See Nuweb manual
% http://nuweb.sourceforge.net/nuweb.pdf
% Personally, the important thing for me is not 
% the usage of the identifiers which can be discovered
% with gtags, or just plain simply while reading the book
% from which module (i.e. chapter) the identifier 
% came from. There is no replacement for gtags
% or doxygen like source-code navigation manuals. 
% But then again, usage lists are important within a module. 
% I would like to understand how identifiers are used 
% within modules, rather than how it uses external 
% modules which I can very well also discover using 
% gtags software or possibly doxygen. 
% In this case, my sections are at the problem level 
% because each problem corresponds to a module. 
% Every model is conceptually different, so there is 
% virtually no overlap, between them. Thus we introduce
% sections at the module level and *not* at the algorithm
% An important part of software engineering is engineering
% such loose (actually super-loose) decoupling between 
% software elements, that allows you to maintain the 
% software and pinpoint bugs effectively. 
% I would say, that it helps to document the internal
% wiring of a module rather than what is exported
% I doubt how that is scalable though. If you want to see
% how another module uses an identifier, you should use gtags. 
% and do the navigation. Thus, identifiers will be used for 
% local wiring. I think it is a good approximate solution. 
% Thus, use @s...@S at the modulelevel. 
%----------------------------------------------------------
@s 
\chapter{Classic Horsefly}
\label{chap:classic-horsefly}

\section{Module Overview}

\newchunk 
All algorithms to solve the classic horsefly problems have been implemented in 
\verb|problem_classic_horsefly.py|. The \verb|run_handler| function acts 
as a kind of main function for this module. It is called from 
\verb|main.py| to process the command-line arguments and run the 
experimental or interactive sections of the code. 

@O ../src/lib/problem_classic_horsefly.py -cp
@{    
@< Relevant imports for classic horsefly @>
@< Set up logging information relevant to this module @>
def run_handler():
    @< Define key-press handler  @>
    @< Set up interactive canvas @>

@< Local data-structures for classic horsefly @>
@< Local utility functions for classic horsefly @>
@< Algorithms for classic horsefly @>
@< Plotting routines for classic horsefly @>
@< Animation routines for classic horsefly @>
@| @}

\section{Module Details}

\newchunk 
@D Relevant imports for classic horsefly
@{
from matplotlib import rc
from colorama import Fore
from colorama import Style
from scipy.optimize import minimize
from sklearn.cluster import KMeans
import argparse
import inspect 
import itertools
import logging
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import os
import pprint as pp
import randomcolor 
import sys
import time
import utils_algo
import utils_graphics
@| @}
\vspace{-0.8cm}\newchunk The logger variable becomes becomes global in scope to this module. This allows
me to write customized \texttt{debug} and \texttt{info} functions that let's me format 
the log messages according to the frame level. I learned this trick from the following 
Stack Overflow post \url{https://stackoverflow.com/a/5500099/505306}. 

@d  Set up logging information relevant to this module 
@{logger=logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def debug(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.debug('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))

def info(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.info('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))
@| @}

\vspace{-0.8cm}\newchunk The key-press handler function detects the keys pressed by the user when the canvas
is in active focus. This function allows you to set some of the input parameters like 
speed ratio $\varphi$, or selecting an algorithm interactively at the command-line, 
generating a bunch of uniform or non-uniformly distributed points on the canvas, 
or just plain clearing the canvas for inserting a fresh input set of points. 

@d Define key-press handler
@{   
# The key-stack argument is mutable! I am using this hack to my advantage.
def wrapperkeyPressHandler(fig,ax, run): 
       def _keyPressHandler(event):
           if event.key in ['i', 'I']:  
                @< Start entering input from the command-line @>
           elif event.key in ['n', 'N', 'u', 'U']: 
                @< Generate a bunch of uniform or non-uniform random points on the canvas @>
           elif event.key in ['c', 'C']: 
                @< Clear canvas and states of all objects @>
       return _keyPressHandler
@| wrapperkeyPressHandler @}

\vspace{-0.8cm}\newchunk 
@D Start entering input from the command-line
@{phi_str = raw_input(Fore.YELLOW + \
          "Enter speed of fly (should be >1): " +\
           Style.RESET_ALL)
phi = float(phi_str)

algo_str = raw_input(Fore.YELLOW + \
          "Enter algorithm to be used to compute the tour:\n Options are:\n" +\
        "  (e)   Exact \n"                                   +\
        "  (t)   TSP   \n"                                   +\
        "  (tl)  TSP   (using approximate L1 ordering)\n"    +\
        "  (k)   k2-center   \n"                             +\
        "  (kl)  k2-center (using approximate L1 ordering)\n"  +\
        "  (g)   Greedy\n"                                   +\
        "  (gl)  Greedy (using approximate L1 ordering])\n"  +\
        "  (ginc) Greedy Incremental  "  +\
        Style.RESET_ALL)

algo_str = algo_str.lstrip()

# Incase there are patches present from the previous clustering, just clear them
utils_graphics.clearAxPolygonPatches(ax)

if   algo_str == 'e':
      horseflytour = \
             run.getTour( algo_dumb,
                          phi )
elif algo_str == 'k': 
      horseflytour = \
             run.getTour( algo_kmeans,
                          phi,
                          k=2,
                          post_optimizer=algo_exact_given_specific_ordering)
      print " "
      print Fore.GREEN, answer['tour_points'], Style.RESET_ALL
elif algo_str == 'kl':
      horseflytour = \
             run.getTour( algo_kmeans,
                          phi,
                          k=2,
                          post_optimizer=algo_approximate_L1_given_specific_ordering)
elif algo_str == 't':
      horseflytour = \
             run.getTour( algo_tsp_ordering,
                          phi,
                          post_optimizer=algo_exact_given_specific_ordering)
elif algo_str == 'tl':
      horseflytour = \
             run.getTour( algo_tsp_ordering,
                          phi,
                          post_optimizer= algo_approximate_L1_given_specific_ordering)
elif algo_str == 'g':
      horseflytour = \
             run.getTour( algo_greedy,
                          phi,
                          post_optimizer= algo_exact_given_specific_ordering)
elif algo_str == 'gl':
      horseflytour = \
             run.getTour( algo_greedy,
                          phi,
                          post_optimizer= algo_approximate_L1_given_specific_ordering)
                          
elif algo_str == 'ginc':
      horseflytour = \
             run.getTour( algo_greedy_incremental_insertion,
                          phi )

else:
      print "Unknown option. No horsefly for you! ;-D "
      sys.exit()

#print horseflytour['tour_points']
plotTour(ax,horseflytour, run.inithorseposn, phi, algo_str)
utils_graphics.applyAxCorrection(ax)
fig.canvas.draw()
@| @}

\vspace{-0.8cm}\newchunk This chunk generates points uniformly or non-uniformly distributed in the 
unit square $[0,1]^2$ in the Matplotlib canvas. I will document the schemes used for 
generating the non-uniformly distributed points later. These schemes are important to test the effectiveness of 
the horsefly algorithms. Uniform point clouds do no highlight the weaknesses of 
sequencing algorithms as David Johnson implies in his article on how to write 
experimental algorithm papers when he talks about algorithms for the TSP. 

@D  Generate a bunch of uniform or non-uniform random points on the canvas
@{numpts = int(raw_input("\n" + Fore.YELLOW+\
                       "How many points should I generate?: "+\
                       Style.RESET_ALL)) 
run.clearAllStates()
ax.cla()
               
utils_graphics.applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                
fig.texts = []
                 
import scipy
if event.key in ['n', 'N']: # Non-uniform random points
        run.sites = utils_algo.bunch_of_random_points(numpts)
else : # Uniform random points
        run.sites = scipy.rand(numpts,2).tolist()

patchSize  = (utils_graphics.xlim[1]-utils_graphics.xlim[0])/140.0

for site in run.sites:      
    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \
                 facecolor='blue',edgecolor='black' ))

ax.set_title('Points : ' + str(len(run.sites)), fontdict={'fontsize':40})
fig.canvas.draw()
@| @}

\vspace{-0.8cm}\newchunk 

@D Clear canvas and states of all objects
@{run.clearAllStates()
ax.cla()
              
utils_graphics.applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                 
fig.texts = []
fig.canvas.draw()
@| @}

\vspace{-0.8cm}\newchunk 
@D Set up interactive canvas
@{fig, ax =  plt.subplots()
run = HorseFlyInput()
#print run
    
ax.set_xlim([utils_graphics.xlim[0], utils_graphics.xlim[1]])
ax.set_ylim([utils_graphics.ylim[0], utils_graphics.ylim[1]])
ax.set_aspect(1.0)
ax.set_xticks([])
ax.set_yticks([])
      
mouseClick   = utils_graphics.wrapperEnterRunPoints (fig,ax, run)
fig.canvas.mpl_connect('button_press_event' , mouseClick )
      
keyPress     = wrapperkeyPressHandler(fig,ax, run)
fig.canvas.mpl_connect('key_press_event', keyPress   )
plt.show()
@| @}



\section{Local Data Structures}

\newchunk This class manages the input and the output of the result of 
calling various horsefly algorithms. 

@D Local data-structures for classic horsefly
@{class HorseFlyInput:
      def __init__(self, sites=[], inithorseposn=()):
           self.sites         = sites
           self.inithorseposn = inithorseposn

           
      def clearAllStates (self):
          """ Set the sites to an empty list and initial horse position 
          to the empty tuple.
          """
          self.sites = []
          self.inithorseposn = ()

          
      def getTour(self, algo, speedratio, k=None, post_optimizer=None):
          """ This method runs an appropriate algorithm for calculating
          a horsefly tour. The list of possible algorithms are 
          inside this module prefixed with 'algo_'
          
          The output is a dictionary of size 2, containing two lists,
          - Contains the vertices of the polygonal 
            path taken by the horse
          - The list of sites in the order 
            in which they are serviced by the tour, i.e. the order 
            in which the sites are serviced by the fly.
          """

          if k==None and post_optimizer==None:
                return algo(self.sites, self.inithorseposn, speedratio)
          elif k == None:
                return algo(self.sites, self.inithorseposn, speedratio, post_optimizer)
          else:
                #print Fore.RED, self.sites, Style.RESET_ALL
                return algo(self.sites, self.inithorseposn, speedratio, k, post_optimizer)
          
      def __repr__(self):
          """ Printed Representation of the Input for HorseFly
          """
          if self.sites != []:
              tmp = ''
              for site in self.sites:
                  tmp = tmp + '\n' + str(site)
              sites = "The list of sites to be serviced are " + tmp    
          else:
              sites = "The list of sites is empty"

          if self.inithorseposn != ():
              inithorseposn = "\nThe initial position of the horse is " + \
                               str(self.inithorseposn)
          else:
              inithorseposn = "\nThe initial position of the horse has not been specified"
              
          return sites + inithorseposn
@| HorseFlyInput @}


Now that all the boring boiler-plate and handler codes have been 
written, its finally time for algorithmic ideas and implementations! 
Every algorithm is given an algorithmic overview followed by the 
detailed steps woven together with the source code. 

Any local utility functions, needed for algorithmic or graphing purposes 
are collected at the end of this chapter. 

\newpage

@i problem-classic-horsefly/algo-dumb.web
@i problem-classic-horsefly/algo-greedy-nn.web
@i problem-classic-horsefly/algo-greedy-incremental-insertion.web
@i problem-classic-horsefly/algo-bottom-up-split.web
@i problem-classic-horsefly/algo-local-search-swap.web
@i problem-classic-horsefly/algo-k2-means.web


@i problem-classic-horsefly/lower-bound-phi-mst.web


\section{Local Utility Functions}

\newchunk  For a given initial position of horse and fly
   return a function computing the tour length. 
   The returned function computes the tour length 
   in the order of the list of stops provided beginning 
   with the initial position of horse and fly. Since 
   the horse speed = 1, the tour length = time taken 
   by horse to traverse the route.

   This is in other words the objective function. 

@D Local utility functions for classic horsefly
@{def tour_length(horseflyinit):
   def _tourlength (x):
         
        # the first point on the tour is the
        # initial position of horse and fly
        # Append this to the solution x = [x0,x1,x2,....]
        # at the front
        htour = np.append(horseflyinit, x)
        length = 0 

        for i in range(len(htour))[:-3:2]:
                length = length + \
                         np.linalg.norm([htour[i+2] - htour[i], \
                                         htour[i+3] - htour[i+1]]) 
        return length

   return _tourlength
@| tour_length @}


\vspace{-0.8cm}\newchunk It is possible that some heuristics might return non-negligible
      waiting times. Hence I am writing a separate function which
      adds the waiting time (if it is positive) to the length of 
      each link of the tour. Again note that because 
      speed of horse = 1, we can add ``time'' to ``distance''. 

@D Local utility functions for classic horsefly
@{def tour_length_with_waiting_time_included(tour_points, horse_waiting_times, horseflyinit):
      tour_points   = np.asarray([horseflyinit] + tour_points)
      tour_links    = zip(tour_points, tour_points[1:])

      # the +1 because the inital position has been tacked on at the beginning
      # the solvers written the tour points except for the starting position
      # because that is known and part of the input. For this function
      # I need to tack it on for tour length
      assert(len(tour_points) == len(horse_waiting_times)+1) 

      sum = 0
      for i in range(len(horse_waiting_times)):

          # Negative waiting times means drone/fly was waiting
          # at rendezvous point
          if horse_waiting_times[i] >= 0:
              wait = horse_waiting_times[i]
          else:
              wait = 0
              
          sum += wait + np.linalg.norm(tour_links[i][0] - tour_links[i][1], ord=2) # 
      return sum
@| tour_length_with_waiting_time_included @}

\section{Plotting Routines}
\newchunk 
@D Plotting routines for classic horsefly 
@{def plotTour(ax,horseflytour, horseflyinit, phi, algo_str, tour_color='#d13131'):
   
    # Route for the horse
    xhs, yhs = [horseflyinit[0]], [horseflyinit[1]]
    for pt in horseflytour['tour_points']:
        xhs.append(pt[0])
        yhs.append(pt[1])

    # List of sites
    xsites, ysites = [], []
    for pt in horseflytour['site_ordering']:
        xsites.append(pt[0])
        ysites.append(pt[1])

    # Route for the fly. The fly keeps alternating
    # between the site and the horse
    xfs , yfs = [xhs[0]], [yhs[0]]
    for site, pt in zip (horseflytour['site_ordering'],
                         horseflytour['tour_points']):
        xfs.extend([site[0], pt[0]])
        yfs.extend([site[1], pt[1]])

    print "\n----------"
    print "Horse Tour"
    print "-----------"
    waiting_times = [0.0] + horseflytour['horse_waiting_times'].tolist() # the waiting time at the starting point is 0
    #print waiting_times
    for pt, time in zip(zip(xhs,yhs), waiting_times) :
        print pt, Fore.GREEN, " ---> Horse Waited ", time, Style.RESET_ALL

    print "\n----------"
    print "Fly Tour"
    print "----------"
    for item, i in zip(zip(xfs,yfs), range(len(xfs))):
        if i%2 == 0:
           print item
        else :
           print Fore.RED + str(item) + "----> Site" +  Style.RESET_ALL

    print "----------------------------------"
    print Fore.GREEN, "\nSpeed of the drone was set to be", phi
    #tour_length = utils_algo.length_polygonal_chain( zip(xhs, yhs))
    tour_length = horseflytour['tour_length_with_waiting_time_included']
    print "Tour length of the horse is ",  tour_length
    print "Algorithm code-Key used "    , algo_str, Style.RESET_ALL
    print "----------------------------------\n"
           
    #kwargs = {'size':'large'}
    for x,y,i in zip(xsites, ysites, range(len(xsites))):
          ax.text(x, y, str(i+1), bbox=dict(facecolor='#ddcba0', alpha=1.0)) 
    ax.plot(xfs,yfs,'g-') # fly tour is green
    ax.plot(xhs, yhs, color=tour_color, marker='s', linewidth=3.0) # horse is red


    # Initial position of horse and fly
    ax.add_patch( mpl.patches.Circle( horseflyinit,
                                      radius = 1/34.0,
                                      facecolor= '#D13131', #'red',
                                      edgecolor='black'   )  )


    fontsize = 20
    tnrfont = {'fontname':'Times New Roman'}
    ax.set_title( r'Algorithm Used: ' + algo_str +  '\nTour Length: ' \
                    + str(tour_length)[:7], fontdict={'fontsize':fontsize}, **tnrfont)
    ax.set_xlabel(r'Number of sites: ' + str(len(xsites)) + '\nDrone Speed: ' + str(phi) ,
                  fontdict={'fontsize':fontsize}, **tnrfont)
@| plotTour @}

\section{Animation routines}

\newchunk 

After writing out the schedule, it would be nice to have a function that animates the 
delivery process of the schedule. Every problem will have animation features unique to
its features. Any abstraction will reveal itself only after I design the various
algorithms and extract the various features. 

In general, all algorithms for a problem will write out a YAML file containing the schedule 
in the outputted run-folder. To animate a schedule and write the resulting movie to disk
we just pass the name of the file containing the schedule. Since the output file-format
of the schedule is identical for all algorithms of a problem, it is sufficient to have
just one animation function. 

Schedules will typically be animated iff there is a \verb|animate_schedule_p| boolean 
flag set to \verb|True| in the arguments of every algorithm's function. 

{\color{red} TODO!! write horsewaiting and drone waiting times to disk too! and incorporate
it into the animation. } 

Here we render the Horse and Fly moving according to their 
assigned tours at their respective speeds, we don't 
need to ``coordinate'' the plotting since that has already 
been done by the scheudle itself. 
    
A site that has been unserviced is represented by a blue dot. 
A site that has been serviced is represented by a pink dot. 
As more and more sites get serviced you should gradually see a pinkening 
of the sites. 
   
At the top of the plot, start a countdown timer of the number 
sites remaining to be serviced. This gives the count of blue dots. 
give the speed ratio as the X-title. Later when waiting times are
incorprated give the time-till liftoff counter too maybe??!!

@d Animation routines for classic horsefly 
@{def animateSchedule(schedule_file_name):
      import yaml
      import numpy as np

      with open(schedule_file_name, 'r') as stream:
            schedule = yaml.load(stream)

      phi           = float(schedule['phi'])
      inithorseposn = schedule['inithorseposn']

      @<Get legs of the horse and fly tours@>
      @<Initialize the movie@>

      for horse_leg, \
          fly_leg,   \
          leg_idx in zip(horse_legs, \
                         fly_legs,   \          
                         range(len(horse_legs))):

           @<Discretize this iteration's horse leg and fly leg@>
           @<Locate the position of site in \verb|fly_leg|@>

           for   horse_posn , \
                 fly_posn,    \
                 subleg_idx in zip(horse_posns, \
                                   fly_posns  , \
                                   range(len(fly_subleg))):
                 @<Render frame and add to animation registry@>
                 @<Render visited and unvisited sites@>
      @<Write animation of schedule to disk@>
      sys.exit()
@| @}


\vspace{-0.8cm} \newchunk
@d Get legs of the horse and fly tours 
@{horse_tour    = map(np.asarray, schedule['horse_tour']   )
sites         = map(np.asarray, schedule['visited_sites'])
     
xhs = [ horse_tour[i][0] for i in range(len(horse_tour))]    
yhs = [ horse_tour[i][1] for i in range(len(horse_tour))]    
xfs , yfs = [xhs[0]], [yhs[0]]
for site, pt in zip (sites,horse_tour[1:]):
         xfs.extend([site[0], pt[0]])
         yfs.extend([site[1], pt[1]])
fly_tour = map(np.asarray,zip(xfs,yfs))

horse_legs = zip(horse_tour, horse_tour[1:])
fly_legs   = zip(fly_tour, fly_tour[1:], fly_tour[2:]) [0::2]

assert(len(horse_legs) == len(fly_legs))
@| horse_legs, fly_legs, fly_tour, horse_tour @}


\vspace{-0.8cm} \newchunk
@d Initialize the movie @{   
pass
@| @}


\vspace{-0.8cm} \newchunk On each of the legs of the horse and fly, 
we place a dense sequence of points, based on their respective speeds. 
By ``subleg'', I refer to this collection of points placed along a leg. 

@d Discretize this iteration's horse leg and fly leg @{   
def discretize_leg(pts,speed):
     subleg_pts = []
     for p,q in zip(pts, pts[1:]):
          for t in np.linspace(0,1,10): ### 10 should be replaced by an appropriate constant
              subleg_pts.append( (1-t)*p + t*q ) 

horse_subleg = discretize_leg(horse_leg,1.0)
fly_subleg   = discretize_leg(fly_leg  ,phi)
@| @}

\vspace{-0.8cm} \newchunk
@d Locate the position of site in \verb|fly_leg| @{   
pass
@| @}

\vspace{-0.8cm}\newchunk
Render the frame. This means all the points along 
horse-leg from 0 till \verb|leg_idx| and then upto 
\verb|subleg_idx| gets rendered. Since the rendering 
happens in memory and not as a write to disk, this 
should get rendered quickly. 

@d Render frame and add to animation registry @{   
pass
@| @}

\vspace{-0.8cm}\newchunk 
@d Render visited and unvisited sites @{   
if subleg_idx == site_loc:
   render as blue
else 
   render sites as pink whatever. 
@| @}



@d Write animation of schedule to disk @{
pass
@}

\section{Chapter Index of Fragments}
@m
\section{Chapter Index of Identifiers}
@u 

%------------------------------------------------------
@S
%------------------------------------------------------