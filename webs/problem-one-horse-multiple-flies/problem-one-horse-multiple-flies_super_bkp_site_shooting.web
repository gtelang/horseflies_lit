@s 
\chapter{One Horse, Multiple Flies}
\label{chap:one-horse-multiple-flies}

\section{Module Overview}
If one fly wasn't exciting enough for you, how about multiple flies?! The added complexity
in the problem comes from finding which sites need to be serviced by each of the flies 
\textit{and} the order in which these sites need to be serviced. To play around with the 
algorithms in interactive mode, run \texttt{main.py} as 

\begin{center}
\texttt{python main.py --problem-one-horse-multiple-flies}. 
\end{center}

The structure of this chapter is similar to \autoref{chap:classic-horsefly}. In fact, 
we will be using some of the algorithms from that chapter as black-box routines in 
the algorithms to be described here. 


All algorithms to solve the multiple flies 
\footnote{For the rest of this chapter we will refer to the one horse, 
multiple flies problem simply as the multiple flies problem.} 
problem have been implemented in \texttt{problem\_one\_horse\_multiple\_flies.py}. 
As bfore, the \verb|run_handler| function acts as a kind of main function for this module. 
It is called from \verb|main.py| to process the command-line arguments and run the 
experimental or interactive sections of the code. 

%{python-mode}%
@O ../src/lib/problem_one_horse_multiple_flies.py -cp
@{    
@< Relevant imports  @>
@< Set up logging information relevant to this module @>
def run_handler():
    @< Define key-press handler  @>
    @< Set up interactive canvas @>

@< Local data-structures  @>
@% @< Local utility functions  @>
@< Algorithms for multiple flies @>
@% @< Lower bounds for multiple flies  @>
@< Plotting routines  @>
@< Animation routines  @>
@| @}
%{/python-mode}%


\newpage

\section{Module Details}
\newchunk 
%{python-mode}%
@d Relevant imports 
@{from colorama import Fore, Style
from matplotlib import rc
from scipy.optimize import minimize
from sklearn.cluster import KMeans
import argparse
import inspect 
import itertools
import logging
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
#plt.style.use('seaborn-poster')
import numpy as np
import os
import pprint as pp
import randomcolor 
import sys
import time
import utils_algo
import utils_graphics

import problem_classic_horsefly as chf
@| @}
%{/python-mode}%


\vspace{-0.8cm}\newchunk The logger variable becomes becomes global in scope to this module. This allows
me to write customized \texttt{debug} and \texttt{info} functions that let's me format 
the log messages according to the frame level. I learned this trick from the following 
Stack Overflow post \url{https://stackoverflow.com/a/5500099/505306}. 
%{python-mode}%
@d  Set up logging information relevant to this module 
@{logger=logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)

def debug(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.debug('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))

def info(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.info('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))
@| @}
%{/python-mode}%

\vspace{-0.8cm}\newchunk The key-press handler function detects the keys pressed by the user when the canvas
is in active focus. This function allows you to set some of the input parameters like 
speed ratio $\varphi$, or selecting an algorithm interactively at the command-line, 
generating a bunch of uniform or non-uniformly distributed points on the canvas, 
or just plain clearing the canvas for inserting a fresh input set of points. 

%{python-mode}%
@d Define key-press handler
@{   
# The key-stack argument is mutable! I am using this hack to my advantage.
def wrapperkeyPressHandler(fig,ax, run): 
       def _keyPressHandler(event):
           if event.key in ['i', 'I']:  
                @< Start entering input from the command-line @>
           elif event.key in ['n', 'N', 'u', 'U']: 
                @< Generate a bunch of uniform or non-uniform random points on the canvas @>
           elif event.key in ['c', 'C']: 
                @< Clear canvas and states of all objects @>
       return _keyPressHandler
@| wrapperkeyPressHandler @}
%{/python-mode}%



\vspace{-0.8cm}\newchunk Before running an algorithm, the user needs to select through 
a menu displayed at the terminal, which one to run. Each algorithm itself, may be 
run under different conditions, so depending on the key-pressed(and thus algorithm chosen) 
further sub-menus will be generated at the command-line. 

After running the appropriate algorithm, we render the structure computed to a matplotlib canvas/window
along with possibly some meta data about the run at the terminal. 

%{python-mode}%

@D Start entering input from the command-line
@{@<Set speed and number of flies@>
@<Select algorithm to execute@>
@| @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk We assume that all flies have the same velocity
%{python-mode}%
@d Set speed and number of flies 
@{
phi_str = raw_input(Fore.YELLOW + "What should I set the speed of each of the flies to be (should be >1)? : " + Style.RESET_ALL)
nof_str = raw_input(Fore.YELLOW + "How many flies do you want me to assign to the horse? : " + Style.RESET_ALL)

phi = float(phi_str)
nof = int(nof_str)
@| @}
%{/python-mode}%



\vspace{-0.8cm} \newchunk Each of the algorithms can have several tuning strategies. 
Depending on the algorithm selected, further sub-menus will have to be generated for 
selecting these sub-strategies. It is best, if all these strategies, are all set 
through a configuration file, like say YAML, rather than have to generate the menus. 

What configurations are valid or not will have to be set later. However, for now, I 
will only implement a simple menu ala classic horsefly to get something working. 
For now, I am implementing the super-drone heuristic with the greedy-incremental 
strategy for the super-drone. For the super-drone category, we will also have 
to specify a partitioning scheme of which sites get assigned to which drones. 

Also the post-optimizer for the super-drone will have to be specified. Too....many....flags! 
Needs a careful documenting in terms of tables of what is allowed and what is not allowed
that is available for ready-reference for the user, and hopefully one that is updated
automatically when the combination is made. Maybe this can be useful for the defense.  

For now, we just stick to super-drones

%{python-mode}%
@d Select algorithm to execute @{
algo_str = raw_input(Fore.YELLOW                                             +\
        "Enter algorithm to be used to compute the tour:\n Options are:\n"   +\
        " (ec)   Earliest Capture \n"                                        +\
        Style.RESET_ALL)

algo_str = algo_str.lstrip()
 
# Incase there are patches present from the previous clustering, just clear them
utils_graphics.clearAxPolygonPatches(ax)

if   algo_str == 'ec':
      tour = run.getTour( algo_greedy_earliest_capture, phi, \
                          number_of_flies = nof)
else:
      print "Unknown option. No horsefly for you! ;-D "
      sys.exit()

utils_graphics.applyAxCorrection(ax)
plot_tour(ax, tour)
fig.canvas.draw()
@| @}
%{/python-mode}%

\vspace{-0.8cm}\newchunk This chunk generates points uniformly or non-uniformly distributed in the 
unit square $[0,1]^2$ in the Matplotlib canvas. I will document the schemes used for 
generating the non-uniformly distributed points later. These schemes are important to test the effectiveness of 
the horsefly algorithms. Uniform point clouds do no highlight the weaknesses of 
sequencing algorithms as David Johnson implies in his article on how to write 
experimental algorithm papers when he talks about algorithms for the TSP. 

Note that the option keys \verb|'n'| or \verb|'N'| for entering in non-uniform random-points is just 
incase the caps-lock key has been pressed on by the user accidentally. Similarly for the \verb|'u'|
and \verb|'U'| keys.  

%{python-mode}%
@D  Generate a bunch of uniform or non-uniform random points on the canvas
@{numpts = int(raw_input("\n" + Fore.YELLOW+\
                       "How many points should I generate?: "+\
                       Style.RESET_ALL)) 
run.clearAllStates()
ax.cla()
               
utils_graphics.applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                
fig.texts = []
                 
import scipy
if event.key in ['n', 'N']: 
        run.sites = utils_algo.bunch_of_non_uniform_random_points(numpts)
else : 
        run.sites = scipy.rand(numpts,2).tolist()

patchSize  = (utils_graphics.xlim[1]-utils_graphics.xlim[0])/140.0

for site in run.sites:      
    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \
                 facecolor='blue',edgecolor='black' ))

ax.set_title('Points : ' + str(len(run.sites)), fontdict={'fontsize':40})
fig.canvas.draw()
@| @}
%{/python-mode}%

\vspace{-0.8cm}\newchunk Clearing the canvas and states of all objects is essential when we want to test out the algorithm on a fresh
new point-set; the program need not be shut-down and rerun. 
%{python-mode}%
@D Clear canvas and states of all objects
@{run.clearAllStates()
ax.cla()
              
utils_graphics.applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                 
fig.texts = []
fig.canvas.draw()
@| @}
%{/python-mode}%

%{python-mode}%
\vspace{-0.8cm}\newchunk 
@D Set up interactive canvas
@{fig, ax =  plt.subplots()
run = MultipleFliesInput()
#print run
    
ax.set_xlim([utils_graphics.xlim[0], utils_graphics.xlim[1]])
ax.set_ylim([utils_graphics.ylim[0], utils_graphics.ylim[1]])
ax.set_aspect(1.0)
ax.set_xticks([])
ax.set_yticks([])
      
mouseClick   = utils_graphics.wrapperEnterRunPoints (fig,ax, run)
fig.canvas.mpl_connect('button_press_event' , mouseClick )
      
keyPress     = wrapperkeyPressHandler(fig,ax, run)
fig.canvas.mpl_connect('key_press_event', keyPress   )
plt.show()
@| @}
%{/python-mode}%

\needspace{7cm}
\section{Local Data Structures}


\newchunk This class manages the input and the output of the result of 
calling various horsefly algorithms. 

%{python-mode}%
@d Local data-structures 
@{class MultipleFliesInput:
      def __init__(self, sites=[], inithorseposn=()):
           self.sites           = sites
           self.inithorseposn   = inithorseposn

      @<Methods for \verb|MultipleFliesInput|@>
@| HorseFlyInput @}
%{/python-mode}%






\vspace{-0.8cm}
\newchunk Set the sites to an empty list and initial horse position to the empty tuple.
%{python-mode}%
@D Methods for \verb|MultipleFliesInput|
@{def clearAllStates (self):
   self.sites = []
   self.inithorseposn = ()
@| clearAllStates @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk 
This method sets an algorithm for calculating
a multiple flies tour. The name of the algorithm is passed as a command-line argument.  
The list of possible algorithms are typically prefixed with \verb|algo_|. 
          
%{python-mode}%
@D Methods for \verb|MultipleFliesInput|
@{def getTour(self, algo, speedratio, number_of_flies):
      return algo(self.sites, self.inithorseposn, speedratio, number_of_flies)
@| getTour @}
%{/python-mode}%

@i problem-one-horse-multiple-flies/algo-greedy-earliest-capture.web

\newpage
\section{Plotting Routines}
\newchunk When an algorithm returns the computed tour, plot that tour upon the provided axis object. 
This is good for quick interactive testing of algorithms, where you can immediately see the output of various
algorithms on the canvas. 
%{python-mode}%
@d Plotting routines @{
def plot_tour(ax, tour):

    sites            = tour['sites']
    inithorseposn    = tour['inithorseposn']
    phi              = tour['phi']
    horse_trajectory = tour['horse_trajectory']
    fly_trajectories = tour['fly_trajectories']

    xhs = [ horse_trajectory[i][0][0] for i in range(len(horse_trajectory))]    
    yhs = [ horse_trajectory[i][0][1] for i in range(len(horse_trajectory))]    

    number_of_flies = len(fly_trajectories)
    colors          = utils_graphics.get_colors(number_of_flies, lightness=0.5)

    ax.cla()
    utils_graphics.applyAxCorrection(ax)
    ax.set_xticks([])
    ax.set_yticks([])

    # Plot fly trajectories
    xfss = [[point['coordinates'][0] for point in fly_trajectories[i]] for i in range(len(fly_trajectories))]
    yfss = [[point['coordinates'][1] for point in fly_trajectories[i]] for i in range(len(fly_trajectories))]
 
    for xfs, yfs,i in zip(xfss,yfss,range(number_of_flies)):
        ax.plot(xfs,yfs,color=colors[i], alpha=0.5)

    # Plot sites along each flys tour
    xfsitess = [ [point['coordinates'][0] for point in fly_trajectories[i] if point['type'] == 'site'] 
                for i in range(len(fly_trajectories))]
    yfsitess = [ [point['coordinates'][1] for point in fly_trajectories[i] if point['type'] == 'site'] 
                for i in range(len(fly_trajectories))]
    
    for xfsites, yfsites, i in zip(xfsitess, yfsitess, range(number_of_flies)):
        for xsite, ysite, j in zip(xfsites, yfsites, range(len(xfsites))):
              ax.add_patch(mpl.patches.Circle((xsite,ysite), radius = 1.0/140, \
                                              facecolor=colors[i], edgecolor='black'))
              ax.text(xsite, ysite, str(j+1), horizontalalignment='center', 
                                              verticalalignment='center'  , 
                                              bbox=dict(facecolor=colors[i], alpha=1.0)) 
    # Plot horse tour
    ax.plot(xhs,yhs,'o-',markersize=5.0, linewidth=2.5, color='#D13131') 
    
    # Plot initial horseposn 
    ax.add_patch( mpl.patches.Circle( inithorseposn,radius = 1.0/100,
                                    facecolor= '#D13131', edgecolor='black'))

@| @}
%{/python-mode}%

\section{Animation routines}
\newchunk The following routine reads the tour in the io file written to disk by the various
algorithms and animates the computed tour. The resulting animation is displayed in a separate 
window, and also saved to disk in the provided directory as an \verb|.avi| file. 
%{python-mode}%
@d Animation routines 
@{def animate_tour(sites, inithorseposn, phi, horse_trajectory, fly_trajectories,animation_file_name_prefix):
     import numpy as np
     import matplotlib.animation as animation
     from   matplotlib.patches import Circle
     import matplotlib.pyplot as plt 

     @<Set up configurations and parameters for animation and plotting@>
     @<Parse \verb|horse_trajectory| and \verb|fly_trajectories| and extract \verb|x| and \verb|y| coordinates along trajectories@>
     @<Construct and store every frame of the animation in \verb|ims| @>
     @<Write animation of tour to disk and display in live window@>

@| animate_tour @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk 
%{python-mode}%
@d Set up configurations and parameters for animation and plotting@{
plt.rc('text', usetex=True)
plt.rc('font', family='serif')

fig, ax = plt.subplots()
ax.set_xlim([0,1])
ax.set_ylim([0,1])
ax.set_aspect('equal')

ax.set_xticks(np.arange(0, 1, 0.1))
ax.set_yticks(np.arange(0, 1, 0.1))

# Turn on the minor TICKS, which are required for the minor GRID
ax.minorticks_on()

# customize the major grid
ax.grid(which='major', linestyle='--', linewidth='0.3', color='red')

# Customize the minor grid
ax.grid(which='minor', linestyle=':', linewidth='0.3', color='black')

ax.get_xaxis().set_ticklabels([])
ax.get_yaxis().set_ticklabels([])

# Visually distinct colors for displaying each flys trajectory in a different color 
number_of_flies = len(fly_trajectories)
colors = utils_graphics.get_colors(number_of_flies)

ax.set_title("Number of sites: " + str(len(sites)), fontsize=25)
ax.set_xlabel(r"$\varphi$ = " + str(phi), fontsize=20)

@| @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk
%{python-mode}%
@d Parse \verb|horse_trajectory| and \verb|fly_trajectories| and extract \verb|x| and \verb|y| coordinates along trajectories
@{
xhs = [ horse_trajectory[i][0][0] for i in range(len(horse_trajectory))]    
yhs = [ horse_trajectory[i][0][1] for i in range(len(horse_trajectory))]    
@| @}
%{/python-mode}%



\vspace{-0.8cm} \newchunk The \verb|ims| array stores each frame of the animation. Every frame consists of 
various ``artist'' objects \footnote{This is Matplotlib terminology} (e.g. circles and segments) 
which change dynamically as the positions of the horse and flies change. 

For the animation, we need to generalize the notion of fly-legs from that of the chapter on the Classic
Horsefly problem. A recorded point on a fly's trajectory is marked as either of type ``genpt''(\verb|g|) 
or ``site''(\verb|s|). Then a fly-leg is either a sequence of points of type ``\verb|gg|'' or ``\verb|gsg|''.  

A horse-leg is, as before, is  a tuple of two successive points along its trajectory. 

For both the horse and flies, their trajectories consist of their corresponding legs joined end-to-end. 

\TODO{Draw a picture here illustrating the concept of a fly-leg, make light all parts of a trajectory 
that are not part of a fly's leg. You can do all this in the same picture, again constructed with asymptote}

%{python-mode}%
@d Construct and store every frame of the animation in \verb|ims|@{
@<Extract the list of horse and fly legs along the horse and fly trajectories respectively@>
ims = []
for leg_idx in range(len(horse_legs)):
    
     @<Define function to place points along a leg@>

     horse_leg = horse_legs[leg_idx]
     flies_leg = [fly_legs[leg_idx] for fly_legs in flies_legs   ]

     # positions of the horse and flies within the current leg
     horse_posns = discretize_leg(horse_legs[leg_idx]) 
     flies_posns = map(discretize_leg, flies_leg)
     
     # all points on horse trajectory uptil the beginning of the current-leg
     hxs = [xhs[i] for i in range(0,leg_idx+1) ]
     hys = [yhs[i] for i in range(0,leg_idx+1) ]
 
     ###############################################################################################################
     # All points on fly trajectories uptil the beginning of the current-leg or last site which ever is first
     fxss, fyss = [], []
     for i in range(number_of_flies):
         tmpx, tmpy = [], []
         for fly_leg, j in zip(flies_legs[i], range(0,leg_idx+1)):
              if fly_leg == None:
                   break

              elif len(fly_leg) == 2: 
                   tmpx.append(fly_leg[0][0])
                   tmpy.append(fly_leg[0][1])

              elif len(fly_leg) == 3:
                   tmpx.append(fly_leg[0][0])
                   tmpy.append(fly_leg[0][1])
                   # this is the site
                   tmpx.append(fly_leg[1][0])
                   tmpy.append(fly_leg[1][1])

         fxss.append(tmpx)
         fyss.append(tmpy)
     #continue
     #fxss = []
     #fyss = []
     #for i in range(number_of_flies):
     #   fxss.append( [ fly_leg[0][0] for fly_leg, j in zip(flies_legs[i], range(0, leg_idx+1)) if fly_leg != None] )
     #   fyss.append( [ fly_leg[0][1] for fly_leg, j in zip(flies_legs[i], range(0, leg_idx+1)) if fly_leg != None] )
     ################################################################################################################

     for horse_posn, subleg_idx in zip(horse_posns,range(len(horse_posns))):
          @<Render frame and append it to \verb|ims|@>
@| @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk
%{python-mode}%
@d Extract the list of horse and fly legs along the horse and fly trajectories respectively @{   
horse_legs = zip(zip(xhs,yhs), zip(xhs,yhs)[1:])
flies_legs = []

for flytraj in fly_trajectories:
    print ".................................................................."
    utils_algo.print_list(flytraj)

    fly_legs = []
    
    for i in range(len(flytraj)-1):
          if flytraj[i]['type'] == 'site': 
              continue                                  # a flyleg never begins with a site, so skip
          else:
              if flytraj[i+1]['type'] == 'site':
                  leg = [flytraj[i]['coordinates'],     # gen_pt
                         flytraj[i+1]['coordinates'],   # site
                         flytraj[i+2]['coordinates']]   # gen_pt
              else:
                  leg = [flytraj[i]['coordinates'],     # gen_pt
                         flytraj[i+1]['coordinates']]   # gen_pt
              fly_legs.append(leg)

    flies_legs.append(fly_legs)

# Pad each flylegs with None
# so that all flylegs have the same 
# length. This makes it convenient for animation
maxnumlegs = max(map(len,flies_legs))

for fly_legs in flies_legs:
    numlegs   = len(fly_legs)
    emptylegs = [None for i in range(maxnumlegs-numlegs)] 
    fly_legs.extend(emptylegs)

# make sure number of horse legs and number of fly legs are the same
num_horse_legs = len(horse_legs)
num_flies_legs = [len(fly_legs) for fly_legs in flies_legs]

# From https://stackoverflow.com/a/3844948 which mentions the efficient list method `.count` on 
# how to check if all elements in a list are identical
assert(num_flies_legs.count(num_horse_legs) == len(num_flies_legs), \
       "Some fly trajectory does not have the same number of legs as the horse trajectory")
@| @}
%{/python-mode}%


\vspace{-0.8cm} \newchunk
%{python-mode}%
@d Render frame and append it to \verb|ims| @{
debug(Fore.RED + "Rendering subleg "+ str(subleg_idx) + Style.RESET_ALL)
hxs1 = hxs + [horse_posn[0]]
hys1 = hys + [horse_posn[1]]
horseline, = ax.plot(hxs1,hys1,'ro-', linewidth=5.0, markersize=6, alpha=1.00)

current_positions_of_flies = []
for i in range(number_of_flies):
    if flies_posns[i] != None :
        current_positions_of_flies.append(flies_posns[i][subleg_idx])
    else:
        current_positions_of_flies.append(fly_trajectories[i][-1]['coordinates'])

flylines = []
for fxs, fys, i in zip(fxss, fyss, range(len(fxss))):
    fxs1 = fxs + [current_positions_of_flies[i][0]]
    fys1 = fys + [current_positions_of_flies[i][1]]
    
    flyline, = ax.plot(fxs1,fys1,'o-', linewidth=1.0, markersize=3, color=colors[i])
    flylines.append(flyline)

objs = [horseline] 

for site in sites:
    circle = Circle((site[0], site[1]), 0.02, \
                    facecolor = 'y'   , \
                    edgecolor = 'black'     , \
                    linewidth=1.4)
    sitepatch = ax.add_patch(circle)
    objs.append(sitepatch)

objs.extend(flylines)

debug(Fore.CYAN + "Appending to ims "+ Style.RESET_ALL)
ims.append(objs[::-1])
@| @}
%{/python-mode}%





%{python-mode}%
@d Define function to place points along a leg 
@{def discretize_leg(pts):
   subleg_pts = []

   if pts == None:
      return None
   else:
      numpts = len(pts)

      if numpts == 2:   # horse leg or fly-leg of type gg
           k  = 19 
      elif numpts == 3: # fly leg of type gsg 
           k  = 10 

      pts = map(np.asarray, pts)
      for p,q in zip(pts, pts[1:]):
          tmp = []
          for t in np.linspace(0,1,k): 
              tmp.append((1-t)*p + t*q) 
          subleg_pts.extend(tmp[:-1])

      subleg_pts.append(pts[-1])
      return subleg_pts
@| @}
%{/python-mode}%



\vspace{-0.8cm} \newchunk
%{python-mode}%
@D Write animation of tour to disk and display in live window
@{from colorama import Back 

debug(Fore.BLACK + Back.WHITE + "\nStarted constructing ani object"+ Style.RESET_ALL)
ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)
debug(Fore.BLACK + Back.WHITE + "\nFinished constructing ani object"+ Style.RESET_ALL)

debug(Fore.MAGENTA + "\nStarted writing animation to disk"+ Style.RESET_ALL)
ani.save(animation_file_name_prefix+'.avi', dpi=150)
debug(Fore.MAGENTA + "\nFinished writing animation to disk"+ Style.RESET_ALL)

plt.show() # For displaying the animation in a live window. 
@| @}
%{/python-mode}%




\needspace{17cm}
\section{Local Utility Functions}
\blindtext
\section{Chapter Index of Fragments}
@m
\section{Chapter Index of Identifiers}
@u 
%------------------------------------------------------
@S
%------------------------------------------------------
\newpage
