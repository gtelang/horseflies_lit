\newpage
\section{\framebox{Algorithm:} Greedy: Earliest Capture}


\section{Algorithmic Overview}
% Give the details of the fly state class here. 

\newchunk
This algorithm is an attempt to directly generalize the greedy nearest neighbor algorithm for collinear horseflies. 
The intuition behind this strategy, is that we try to greedily minimize the time between two successive rendezvous 
points of the horse with any of the flies. Once the horse meets up with a fly, there are several alternatives about 
the next site it should be deployed to. We again follow a greedy strategy here, and deploy 
it to the nearest ``unclaimed'' site \footnote{There might be several interesting
algorithmic questions lurking on how to select the next unclaimed site that the fly should be deployed to. 
Can we do some analogue of incremental? Fast methods for detecting the best place of insertion would be eminently 
interesting, and fun to implement via literate programming!}. The next chunk introduces the necessary terminology 
and a detailed algorithmic implementation of the earliest capture heuristic. See Figure?? for an illustration of the 
progress of the algorithm for 2 drones and 6 sites. 

%%%%% Insert pictures of algorithm's progress here %%%%%%% 


\newchunk We say that a site is ``claimed'' when some fly is heading towards it \underline{\textit{or}} has been 
serviced by a fly already. In each iteration of the \verb|while| loop, the horse rendezvous with one of the deployed flies. 
The horse moves towards the site assigned to the rendezvousing fly along the segment joining its current position and that site. 
It keeps moving along this segment until it meets the fly. \footnote{It is important that we assume that 
$\varphi \geq 1$ for this to work, otherwise more control flow will have to be introduced. Anyway, in the real-world 
we will always be dealing with drones which are faster than the trucks, so doing that would be pointless}

As the horse moves towards this site, the remaining flies, if they are returning from sites that they have just serviced, 
change their direction of motion and move towards the rendezvous point of the horse and selected fly. 
On meeting up with a fly, the horse redeploys it to an unclaimed site, if one exists and update the corresponding \verb|FlyState|
object. We keep repeating this process until all sites have been serviced and all flies have been retired. 

A fly is deemed ``retired'' when it returns to the horse and will no longer be deployed to \textit{any} site 
\footnote{It continutes lugging along with the horse after this point in time, so to speak}. This will 
typically happen when the number of unclaimed sites near the end of the algorithm's run is less than the total number of flies. 
The \verb|FlyState| class tracks information (such as trajectory, current assigned site etc.) 
about a single fly from the moment it was deployed from  \verb|inithorseposn| till it returns to the horse after its 
last delivery.

In this implementation,  we will deploy a fly to the nearest \textit{unclaimed} site at each rendezvous point with the horse.  
\footnote{Although I will need to be able to configure this via some policy argument later.}

%{python-mode}%
@D Algorithms for multiple flies 
@{
@<Definition of the \verb|FlyState| class @>
def algo_greedy_earliest_capture(sites, inithorseposn, phi, number_of_flies, 
                                 write_algo_states_to_disk_p, = True
                                 animate_schedule_p           = True):
    @<Helper functions for \verb|algo_greedy_earliest_capture|@>    
    @<Initialize all the fly states@>

    all_flies_retired_p = False

    while (not all_flies_retired_p):
         @<Find the best fly state to complete@>
         @<Update states of all fly states and redeploy rendezvousing fly@> 
         @<Update list of unclaimed sites@>
         @<Update value of \verb|all_flies_retired_p|@>
         @<Write algorithms current state to file, if \verb|write_algo_states_to_disk_p == True|@> 
    
    @<Write input and output to file@>
    @<Make an animation of the schedule if \verb|animate_schedule_p == True| @>
    @<Return multiple flies tour with additional information @>
@| @}
%{/python-mode}%


\section{Algorithmic Details}
% This particular algorithm will scale nicely on the computer to a 1000 sites very easily, without any 
% fancy convex optimization solvers and what not. Besides it is a natural analogue of greedy-collinear 
% nearest neighbor horseflies. Wonder what nearest neighbor insertion will look like here? There is 
% an analogue indeed, but it will involve expensive recalculation naively, but place it somewhere inside
% within the fingers. Which fly to reassign to and in what order, that is a separate and nice question in
% of itself. 

\newchunk
%{python-mode}%
@d Definition of the \verb|FlyState| class @{
class FlyState:
    def __init__(self, initflyposn, site):
         self.flytraj                           = [initflyposn]
         self.current_assigned_site             = site
         self.current_assigned_site_serviced_p  = False
         self.fly_retired_p                     = False
@| @}
%{/python-mode}%

