
\section{Algorithm: Greedy---Nearest Neighbor}  

\subsection{Algorithmic Overview}

\subsection{Algorithmic Details}
@D Algorithms for classic horsefly 
@{   
def algo_greedy(sites, inithorseposn, phi, post_optimizer):
      """
      This implements the greedy algorithm for the canonical greedy
      algorithm for collinear horsefly, and then uses the ordering 
      obtained to get the exact tour for that given ordering.
      
      Many variations on this are possible. However, this algorithm
      is simple and may be more amenable to theoretical analysis. 
      
      We will need an inequality for collapsing chains however. 
      """
      def next_rendezvous_point_for_horse_and_fly(horseposn, site):
            """
            Just use the exact solution when there is a single site. 
            No need to use the collinear horse formula which you can 
            explicitly derive. That formula is  an important super-special 
            case however to benchmark quality of solution. 
            """

            horseflytour = algo_exact_given_specific_ordering([site], horseposn, phi)
            return horseflytour['tour_points'][-1]
      
      # Begin the recursion process where for a given initial
      # position of horse and fly and a given collection of sites
      # you find the nearst neighbor proceed according to segment
      # horsefly formula for just and one site, and for the new
      # position repeat the process for the remaining list of sites. 
      # The greedy approach can be extended to by finding the k
      # nearest neighbors, constructing the exact horsefly tour
      # there, at the exit point, you repeat by taking k nearest
      # neighbors and so on. 
      def greedy(current_horse_posn, remaining_sites):
            if len(remaining_sites) == 1:
                  return remaining_sites
            else:
                  # For reference see this link on how nn queries are performed. 
                  # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html
                  # Warning this is inefficient!!! I am rebuilding the kd-tree at each step. 
                  # Right now, I am only doing this for convenience.
                  from scipy import spatial
                  tree = spatial.KDTree(remaining_sites)

                  # The next site to get serviced by the drone and horse
                  # is the one which is closest to the current position of the
                  # horse. 
                  pts           = np.array([current_horse_posn])
                  query_result  = tree.query(pts)
                  next_site_idx = query_result[1][0]
                  next_site     = remaining_sites[next_site_idx]

                  next_horse_posn = \
                        next_rendezvous_point_for_horse_and_fly(current_horse_posn, next_site)
                  #print remaining_sites
                  remaining_sites.pop(next_site_idx) # the pop method modifies the list in place. 
                  
                  return [ next_site ] + greedy (current_horse_posn = next_horse_posn, \
                                                 remaining_sites    = remaining_sites)

      sites1 = sites[:]
      sites_ordered_by_greedy = greedy(inithorseposn, remaining_sites=sites1)

      # Use exact solver for the post optimizer step
      answer = post_optimizer(sites_ordered_by_greedy, inithorseposn, phi)
      return answer
@| @}

