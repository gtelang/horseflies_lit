\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
\documentclass[11pt]{report}
\input{standard_settings.tex}
\usepackage{tocloft}
\renewcommand{\cftpartfont}{\LARGE\itshape} % Part title in Huge Italic font
\usepackage{hyperref}
\usepackage{etoolbox}

% Better formatting of backticks in 
% verbatim environment. 
\usepackage{upquote}

% page numbering at top right
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

\begin{document}
\begin{titlepage}
	\centering
        {\Huge Experimental Analyses of Heuristics for Horsefly-type Problems\\}
        \vspace{20mm}
        {\Large Gaurish Telang}
\end{titlepage}
% This gives the titlepage the page number of 1, 
% making it easier to navigate with a pdfviewer
% such as zathura, which seems to only be able 
% to understand page-numbers beginning from 1. 
\pagenumbering{arabic}
\setcounter{page}{2} 

% For global table of contents
\setcounter{tocdepth}{1}
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\part{Overview}
\chapter{Descriptions of Problems}
\label{chap:descriptions-of-problems}


\begin{figure}[H]
  \centering

  \includegraphics[width=8cm]{../webs/docs/prelim_example_phi5.png}
  \caption{An Example of a classic Horsefly tour with $\varphi=5$. The red dot
    indicates the initial position of the horse and fly, given as part of 
    the input. The ordering of sites shown has been computed with a greedy 
    algorithm which will be described later}
  \label{fig:prelim-example}
\end{figure}


The Horsefly problem is a generalization of the well-known Euclidean Traveling Salesman Problem.
In the most basic version of the Horsefly problem (which we call \textbf{``Classic Horsefly''}), we are given a set of sites, the
initial position of a truck(horse) with a drone(fly) mounted on top, and the speed of the
drone-speed $\varphi$. \footnote{ The speed of the truck is always assumed to be 1 in any of the problem 
  variations we will be considering in this report.} \footnote{ $\varphi$ is also called the ``speed ratio''.}. 

The goal is to compute a tour for both the truck and the drone to deliver package to sites
as quickly as possible. For delivery, a drone must pick up a package from the
truck, fly to the site and come back to the truck to pick up the next package for
delivery to another site. \footnote{ The drone is assumed to be able to carry at most one package at a time }
Both the truck and drone must coordinate their motions to minimize the time it takes for
all the sites to get their packages. Figure \ref{fig:prelim-example} gives an example of such a tour
computed using a greedy heuristic for $\varphi=5$.


This suite of programs implement several experimental heuristics, to solve the above NP-hard
problem and some of its variations approximately. In this short chapter, we give a description 
of the problem variations that we will be tackling. Each of the problems, has a corresponding chapter 
in Part 2, where these heuristics are described and implemented. We also give comparative analyses of 
their experimental performance on various problem instances. 

\vspace{0.5cm}

\begin{description}
\item[Classic Horsefly] This problem has already described in the introduction.

\item[Segment Horsefly] In this variation, the path of the truck is restricted to that of a segment, 
  which we can consider without loss of generality to be $[0,1]$. All sites, without loss of generality 
  lie in the upper-half plane $\RR^2_{+}$. 

\item[Fixed Route Horsefly] This is the obvious generalization of Segment Horsefly, where the path
  which the truck is restricted to travel is a piece-wise linear polygonal path. 
  \footnote{More generally, the truck will be restricted to travelling on a road network, which would 
    typically be modelled as a graph embedded in the plane.} Both the initial 
  position of the truck and the drone are given. The sites to be serviced are allowed to lie anywhere in $\RR^2$. 
  Two further variations are possible in this setting, one in which the truck is allowed reversals
  and the other in which it is not. 

\item[One Horse, Two Flies] The truck is now equipped with two drones. Otherwise the setting, is exactly 
  the same as in classic horsefly. Each drone can carry only one package at a time. The drones must fly back
  and forth between the truck and the sites to deliver the packages. We allow the possibility that 
  both the drones can land at the same time and place on the truck to pick up their next package. \footnote{In reality, 
    one of the drones will have to wait for a small amount of time while the other is retrieving its package. 
    In a more realisting model, we would need to take into account this ``waiting time'' too.}

\item[Reverse Horsefly] In this model, each site (not the truck!) is equipped with a drone, which fly 
  \textit{towards} the truck to pick up their packages. We need to coordinate the motion of the truck 
  and drone so that the time it takes for the last drone to pick up its package (the ``makespan'') is 
  minimized. 

\item[Bounded Distance Horsefly] In most real-world scenarios, the drone will not be able to (or allowed to) go more than
  a certain distance $R$ from the truck. Thus with the same settings as the classic horsefly, but with the added 
  constraint of the drone and the truck never being more than a distance $R$ from the truck, how would one 
  compute the truck and drone paths to minimize the makespan of the deliveries? 

\item[Watchman Horsefly] In place of the TSP, we generalize the Watchman route problem here. 
  \footnote{ although abstractly, the Watchman route problem can be viewed as a kind of TSP}
  We are given as input a simple polygon and the initial position of a truck and a drone. The drone has 
  a camera mounted on top which is assumed to have $360^{\circ}$ vision. Both the truck and drone can move, 
  but the drone can move at most euclidean distance \footnote{The version where instead geodesic distance is 
    considered is also interesting} $R$ from the truck. 

  We want every point in the polygon to be seen by the drone at least once. The goal is to minimize the time it 
  takes for the drone to be able to see every point in the simple polygon. In other words, we want to minimize
  the time it takes for the drone (moving in coordinattion with the truck) to patrol the entire polygon. 
  
\end{description}

\chapter{Installation and Use}

To run these programs you will need to install Docker, an open-source containerization program that is easily installable on 
  Windows 10\footnote{You might need to turn on virtualization explicitly in your BIOS, after installing Docker 
  as I needed to while setting Docker up on Windows. Here is a snapshot of an image when turning on Intel's 
  virtualization technology through the BIOS: 
\url{https://images.techhive.com/images/article/2015/09/virtualbox_vt-x_amd-v_error04_phoenix-100612961-large.idge.jpg}}, MacOS, and almost any 
  GNU/Linux distribution. For a quick introduction to containerization, watch the first two minutes of 
  \url{https://youtu.be/_dfLOzuIg2o}

The nice thing about Docker is that it makes it easy to run softwares on different OS'es portably and neatly side-steps the 
dependency hell problem (\url{https://en.wikipedia.org/wiki/Dependency_hell}.) The headache of installing different library 
dependencies correctly on different machines running different OS'es, is replaced \textbf{only} by learning how to 
install Docker and to set up an X-windows connection between the host OS and an instantiated container running GNU/Linux. 

\begin{alphalist}
\item \crunchy{Get Docker} For installation instrutions watch
  \begin{description}
    \item[GNU/Linux]  \url{https://youtu.be/KCckWweNSrM}
    \item[Windows]    \url{https://youtu.be/ymlWt1MqURY}
    \item[MacOS]      \url{https://youtu.be/MU8HUVlJTEY}
  \end{description}

\item \crunchy{Download customized Ubuntu image} \verb| docker pull gtelang/ubuntu_customized| \footnote{The customized Ubuntu image is approximately
  7 GB which contains all the libraries (e.g. CGAL, VTK, numpy, and matplotlib) that I typically use to run 
  my research codes portably.On my home internet connection downloading this Ubuntu-image typically takes about 5 minutes. }
\item \crunchy{Clone repository} \verb|git clone gtelang/horseflies_literate.git|
\item \crunchy{Mount and Launch} 
\begin{description}
\item[For GNU/Linux] Open up your favorite terminal emulator, such xterm and then
{\small
\begin{itemize}
   \item Copy to clipboard the output of \verb|xauth list|
   \item \verb|cd horseflies_literate|
   \item \verb|docker run -it --name horsefly_container --net=host -e DISPLAY -v /tmp/.X11-unix -v `pwd`:/horseflies_mnt gtelang/ubuntu_customized|
   \item \verb|cd horseflies_mnt| 
   \item \verb|xauth add | \textit{<paste-from-clipboard>}
\end{itemize}}
\item[For Windows] I had to follow the instructions in 
      \url{https://dev.to/darksmile92/run-gui-app-in-linux-Docker-container-on-windows-host-4kde} to be 
      able to run graphical user applications
\end{description}

\item \crunchy{Run experiments} If you want to run all the experiments as described in 
  the paper again to reproduce the reported results on your machine, then run \footnote{ Allowing, of course,
  for differences between your machine's CPU and mine when it comes to reporting absolute running time}, \\
  \verb|python main.py --run-all-experiments|. 

  If you want to run a specific experiment, then run \\ \verb|python main.py --run-experiment <experiment-name>|. 

  See Index for a list of all the experiments. 

\item \crunchy{Test algorithms interactively}  If you want to test the algorithms in interactive mode 
  (where you get to select the problem-type, mouse-in the sites on a canvas, set the initial position of 
  the truck and drone and set $\varphi$), run \verb|python main.py --<problem-name>|. The
  list of problems are the same as that given in the previous chapter. The problem name consists
  of all lower-case letters with spaces replaced by hyphens. 

  Thus for instance ``Watchman Horsefly'' becomes \verb|watchman-horsefly| and ``One Horse Two Flies''
  becomes \verb|one-horse-two-flies|. 

  To interactively experiment with different algorithms for, say, the Watchman Horsefly problem , 
  type at the terminal \verb|python main.py --watchman-horsefly|
\end{alphalist}

\vspace{1cm}

If you want to delete the Ubuntu image and any associated containers run the command \footnote{the ubuntu image is 7GB afterall!}
\begin{verbatim}
 docker rm -f horsefly_container; docker rmi -f ubuntu_customized
\end{verbatim}

That's it! Happy horseflying!
\part{Programs}
\chapter{Overview of the Code Base}
NOTE: {\footnotesize The style of presentation in this chapter has been adapted from 
Chapter 2 of the Nuweb reference manual \url{http://nuweb.sourceforge.net/nuweb.pdf}}

Almost all of the code has been written in Python 2.7 and tested using the standard CPython
implementation of the language. In some cases, calls will be made to external C\texttt{++} libraries (mostly CGAL and VTK) 
using SWIG (\url{http://www.swig.org/}). This is either for speeding up a slow 
routine or to use a function that is not available in any existing Python package.

\section{Source Tree}
\input{directory-tree.tex}

There are three principal directories 
\begin{itemize}
 \item[\texttt{webs/}] This contains the source code for the entire project written in the nuweb format along with documents (mostly images)
                       needed during the compilation of the \LaTeX{} files which will be extracted from the \texttt{.web} files. 
 \item[\texttt{src/}] This contains the source code for the entire project ``tangled'' (i.e. extracted) from the \texttt{.web} files. 
 \item[\texttt{tex/}] This contains the monolithic \texttt{horseflies.tex} extracted from the \texttt{.web} files and a bunch 
of other supporing \LaTeX{} files. It also contains the final compiled \texttt{horseflies.pdf} (the current document) which contains the 
documentation of the project, interwoven with code-chunks and cross-references between them along with the experimental results.  
\end{itemize}  

The files in \texttt{src} and \texttt{tex} should not be touched. Any editing required should 
be done to the \texttt{.web} files, which should then be weaved and tangled using the
script \texttt{weave-tangle.sh} in the \texttt{webs} directory. 

\section{The Main Files} 


\newchunk Each of the files with prefix \texttt{problem-*}  contain implmentations of 
 algorithms for one specific problem. Thus \texttt{problem-watchman-horsefly.py} 
 contains algorithms for approximately solving the Watchman Horsefly problem. 

 All such files are in the directory \texttt{src/lib/}

\newchunk Similarly, each of the files with prefix \texttt{expt-*} contain code
 for testing hypotheses regarding a problem, generating counter-examples or 
 comparing the experimental performance of the algorithm implementations 
 for each of the problems. Thus \texttt{expt-watchman-horsefly.py} contains 
 code for performing experiments related to the Watchman Horsefly problem. 

 All such files are in the directory \texttt{src/expt/}

\newchunk The file \verb|main.py| in the top-level folder is the \textit{entry-point} for running code. 
Its only job is to parse the command-line arguments and pass relevant information to the handler 
functions for each problem and experiment. 

Each problem or experiment has a handler routine 
that effectively acts as a kind of ``main'' function for that module that does some house-keeping duties by 
parsing the command-line arguments passed  by main, setting up the canvas by calling the appropriate
graphics routines and calling the algorithms on the input specified through the canvas. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap1}\raggedright\small
\NWtarget{nuweb13}{} \verb@"../main.py"@\nobreak\ {\footnotesize {13}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@sys.path.append('src/lib')@\\
\mbox{}\verb@@\\
\mbox{}\verb@import problem_classic_horsefly as chf@\\
\mbox{}\verb@#import problem_segment_horsefly as shf@\\
\mbox{}\verb@#import problem_one_horse_two_flies as oh2f@\\
\mbox{}\verb@   @\\
\mbox{}\verb@if __name__=="__main__":@\\
\mbox{}\verb@     # Select algorithm or experiment @\\
\mbox{}\verb@     if (len(sys.argv)==1):@\\
\mbox{}\verb@          print "Specify the problem or experiment you want to run"@\\
\mbox{}\verb@          sys.exit()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-classic-horsefly":@\\
\mbox{}\verb@          chf.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-segment-horsefly":@\\
\mbox{}\verb@          shf.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-one-horse-two-flies":@\\
\mbox{}\verb@          oh2f.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     else:@\\
\mbox{}\verb@          print "Option not recognized"@\\
\mbox{}\verb@          sys.exit()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Support Files}
\newchunk These files contain common utility functions that will be useful for manipulating
 data-structures, common plotting and graphics routines for all horsefly-type 
 problems. All such files have the prefix \texttt{utils-*}

 All such files are in the directory \texttt{src/lib/}

\newchunk To automate testing of code during implementations, tests for various 
 routines across the entire code-base have been written in files with prefix
 \texttt{test-*}.  

 Each of the main files have a corresponding test file. Tests for functions in the 
 support files and experimental files have all been implemented in the files 
 \texttt{test-utilities.py} and \texttt{test-experiments.py} respectively.  
       
 All such files are in the directory \texttt{src/test/}
 \chapter{Some (Boring) Utility Functions}
\label{chap:utility-functions}

We will be needing some utility functions, for drawing and manipulating data-structures 
which will be implemented in files separate from \verb|problem_classic_horsefly.py|.  All such
files will be prefixed with the work \verb|utils_|. Many of the important common utility 
functions are defined here; others will be defined on the fly throughout the rest of the report. 
This chapter just collects the most important of the functions for the sake of clarity of exposition
in the later chapters. 

\section{Graphical Utilities}

Here We will  develop routines to interactively insert points onto a Matplotlib canvas and clear the canvas. 
Almost all variants of the horsefly problem will involve mousing in sites and the initial position of the horse 
and fly. These points will typically be represented by small circular patches. The type of the point
will be indicated by its color and size e.g. intial position of truck and drone 
will typically be represented by a large red dot while and the sites by smaller blue dots. 

Matplotlib has extensive support for inserting such circular patches onto its canvas with 
mouse-clicks. Each such graphical canvas corresponds (roughly) to Matplotlib figure
object instance. Each figure consists of several Axes objects which contains
most of the figure elements i.e. the Axes objects correspond to the ``drawing area''
of the canvas. 

\newchunk First we set up the axes limits, dimensions and other configuration quantities
which will correspond to the ``without loss of generality'' assumptions made in the 
statements of the horsefly problems. We also need to set up the axes limits,
dimensions, and other fluff. The following fragment defines a function which 
``normalizes'' a drawing area by setting up the x and y limits and making the 
aspect ratio of the axes object the same i.e. 1.0. Since Matplotlib is principally
a plotting software, this is not the default behavior, since scales on the x and y 
axes are adjusted according to the data to be plotted. 

\begin{flushleft} \small\label{scrap2}\raggedright\small
\NWtarget{nuweb15}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {15}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@@\\
\mbox{}\verb@xlim, ylim = [0,1], [0,1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@def applyAxCorrection(ax):@\\
\mbox{}\verb@      ax.set_xlim([xlim[0], xlim[1]])@\\
\mbox{}\verb@      ax.set_ylim([ylim[0], ylim[1]])@\\
\mbox{}\verb@      ax.set_aspect(1.0)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb15}{15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17a}{, 17a}\NWlink{nuweb17b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Next, given an axes object (i.e. a drawing area on a figure object) we need a function
to delete and remove all the graphical objects drawn on it. 

\begin{flushleft} \small\label{scrap3}\raggedright\small
\NWtarget{nuweb16}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {16}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def clearPatches(ax):@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Remove line patches. These get inserted during the r=2 case,@\\
\mbox{}\verb@    # For some strange reason matplotlib does not consider line objects@\\
\mbox{}\verb@    # as patches.@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    #pp.pprint (ax.patches) # To verify that none of the patches are@\\
\mbox{}\verb@    # polyon patches corresponding to clusters.@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb15}{15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17a}{, 17a}\NWlink{nuweb17b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Now remove the patches which were rendered for each cluster
    Unfortunately, this step has to be done manually, the canvas patch
    of a cluster and the corresponding object in memory are not reactively
    connected.I presume, this behavioue can be achieved by sub-classing.

\begin{flushleft} \small\label{scrap4}\raggedright\small
\NWtarget{nuweb17a}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {17a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def clearAxPolygonPatches(ax):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Remove line patches. These get inserted during the r=2 case,@\\
\mbox{}\verb@    # For some strange reason matplotlib does not consider line objects@\\
\mbox{}\verb@    # as patches.@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # To verify that none of the patches @\\
\mbox{}\verb@    # are polyon patches corresponding @\\
\mbox{}\verb@    # to clusters.@\\
\mbox{}\verb@    #pp.pprint (ax.patches) @\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb15}{15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17a}{, 17a}\NWlink{nuweb17b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Now for one of the most important routines for drawing on the canvas! 
To insert the sites, we double-click the left mouse button and to insert the 
initial position of the horse and fly we double-click the right mouse-button. 

Note that the left mouse-button corresponds to button 1 and right mouse button
to button 3 in the code-fragment below. 

\begin{flushleft} \small\label{scrap5}\raggedright\small
\NWtarget{nuweb17b}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {17b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@## Also modify to enter initial position of horse and fly@\\
\mbox{}\verb@def wrapperEnterRunPoints(fig, ax, run):@\\
\mbox{}\verb@    """ Create a closure for the mouseClick event.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    def _enterPoints(event):@\\
\mbox{}\verb@        if event.name     == 'button_press_event'      and \@\\
\mbox{}\verb@           (event.button   == 1 or event.button == 3)  and \@\\
\mbox{}\verb@           event.dblclick == True                      and \@\\
\mbox{}\verb@           event.xdata    != None                      and \@\\
\mbox{}\verb@           event.ydata    != None:@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 1:        @\\
\mbox{}\verb@               newPoint = (event.xdata, event.ydata)@\\
\mbox{}\verb@               run.sites.append( newPoint  )@\\
\mbox{}\verb@               patchSize  = (xlim[1]-xlim[0])/140.0@\\
\mbox{}\verb@   @\\
\mbox{}\verb@               ax.add_patch( mpl.patches.Circle( newPoint,@\\
\mbox{}\verb@                                              radius = patchSize,@\\
\mbox{}\verb@                                              facecolor='blue',@\\
\mbox{}\verb@                                              edgecolor='black'   )  )@\\
\mbox{}\verb@               ax.set_title('Points Inserted: ' + str(len(run.sites)), \@\\
\mbox{}\verb@                             fontdict={'fontsize':40})@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 3:        @\\
\mbox{}\verb@                 inithorseposn = (event.xdata, event.ydata)@\\
\mbox{}\verb@                 run.inithorseposn = inithorseposn  @\\
\mbox{}\verb@                 patchSize  = (xlim[1]-xlim[0])/70.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 # TODO: remove the previous red patches, @\\
\mbox{}\verb@                 # which containg ht eold position@\\
\mbox{}\verb@                 # of the horse and fly. Doing this is @\\
\mbox{}\verb@                 # slightly painful, hence keeping it@\\
\mbox{}\verb@                 # for later@\\
\mbox{}\verb@                 ax.add_patch( mpl.patches.Circle( inithorseposn,@\\
\mbox{}\verb@                                                   radius = patchSize,@\\
\mbox{}\verb@                                                   facecolor= '#D13131', #'red',@\\
\mbox{}\verb@                                                   edgecolor='black'   )  )@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@             # It is inefficient to clear the polygon patches inside the@\\
\mbox{}\verb@             # enterpoints loop as done here.@\\
\mbox{}\verb@             # I have just done this for simplicity: the intended behaviour@\\
\mbox{}\verb@             # at any rate, is@\\
\mbox{}\verb@             # to clear all the polygon patches from the axes object,@\\
\mbox{}\verb@             # once the user starts entering in MORE POINTS TO THE CLOUD@\\
\mbox{}\verb@             # for which the clustering was just computed and rendered.@\\
\mbox{}\verb@             # The moment the user starts entering new points,@\\
\mbox{}\verb@             # the previous polygon patches are garbage collected. @\\
\mbox{}\verb@             clearAxPolygonPatches(ax)@\\
\mbox{}\verb@             applyAxCorrection(ax)@\\
\mbox{}\verb@             fig.canvas.draw()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return _enterPoints@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb15}{15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17a}{, 17a}\NWlink{nuweb17b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Algorithmic Utilities}

\newchunk Given a list of  points $[p_0,p_1,p_2,....p_{n-1}]$. 
    the following function returns, $[p_1-p_0, p_2-p_1,...,p_{n-1}-p_{n-2}]$
    i.e. it converts the list of points into a consecutive list of numpy vectors. 
    Points should be lists or tuples of length 2

\begin{flushleft} \small\label{scrap6}\raggedright\small
\NWtarget{nuweb19}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {19}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import random@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def vector_chain_from_point_list(pts):@\\
\mbox{}\verb@    """ Given a list of points [p0,p1,p2,....p(n-1)]@\\
\mbox{}\verb@    Make it into a list of numpy vectors @\\
\mbox{}\verb@    [p1-p0, p2-p1,...,p(n-1)-p(n-2)]@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    Points should be lists or tuples of length 2@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    vec_chain = []@\\
\mbox{}\verb@    for pair in zip(pts, pts[1:]):@\\
\mbox{}\verb@        tail= np.array (pair[0])@\\
\mbox{}\verb@        head= np.array (pair[1])@\\
\mbox{}\verb@        vec_chain.append(head-tail)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return vec_chain@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Given a polygonal chain, an important computation is to calculate 
its length. Typically used for computing the length of the horse's and fly's tours. 

\begin{flushleft} \small\label{scrap7}\raggedright\small
\NWtarget{nuweb20a}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {20a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def length_polygonal_chain(pts):@\\
\mbox{}\verb@    """ Given a list of points [p0,p1,p2,....p(n-1)]@\\
\mbox{}\verb@    calculate the length of its segments. @\\
\mbox{}\verb@@\\
\mbox{}\verb@    Points should be lists or tuples of length 2@\\
\mbox{}\verb@@\\
\mbox{}\verb@    If no points or just one point is given in the list of@\\
\mbox{}\verb@    points, then 0 is returned.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    vec_chain = vector_chain_from_point_list(pts)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    acc = 0@\\
\mbox{}\verb@    for vec in vec_chain:@\\
\mbox{}\verb@        acc = acc + np.linalg.norm(vec)@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk The following routine is useful on long lists returned from external solvers. 
Often point-data is given to and returned from these external routines in flattened
form. The following routines are needed to convert such a ``flattened'' list into 
a list of points and vice versa. 

\begin{flushleft} \small\label{scrap8}\raggedright\small
\NWtarget{nuweb20b}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {20b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def pointify_vector (x):@\\
\mbox{}\verb@    """ Convert a vector of even length @\\
\mbox{}\verb@    into a vector of points. i.e.@\\
\mbox{}\verb@    [x0,x1,x2,...x2n] -> [[x0,x1],[x2,x3],,..[x2n-1,x2n]]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    if len(x) % 2 == 0:@\\
\mbox{}\verb@        pts = []@\\
\mbox{}\verb@        for i in range(len(x))[::2]:@\\
\mbox{}\verb@            pts.append( [x[i],x[i+1]] )@\\
\mbox{}\verb@        return pts@\\
\mbox{}\verb@    else :@\\
\mbox{}\verb@        sys.exit('List of items does not have an even length to be able to be pointifyed')@\\
\mbox{}\verb@@\\
\mbox{}\verb@def flatten_list_of_lists(l):@\\
\mbox{}\verb@    """ Flatten vector@\\
\mbox{}\verb@      e.g.  [[0,1],[2,3],[4,5]] -> [0,1,2,3,4,5]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    return [item for sublist in l for item in sublist]@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Python's default print function prints each list on a single line. For 
debugging purposes,  it helps to print a list with one item per line. 

\begin{flushleft} \small\label{scrap9}\raggedright\small
\NWtarget{nuweb21a}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {21a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def print_list(xs):@\\
\mbox{}\verb@    """ Print each item of a list on new line@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        print x@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk The following routines are self-explanatory and are hence gathered into one chunk. 

\begin{flushleft} \small\label{scrap10}\raggedright\small
\NWtarget{nuweb21b}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {21b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def partial_sums( xs ):@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    List of partial sums@\\
\mbox{}\verb@    [4,2,3] -> [4,6,9]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    psum = 0@\\
\mbox{}\verb@    acc = []@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        psum = psum+x@\\
\mbox{}\verb@        acc.append( psum )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@@\\
\mbox{}\verb@def are_site_orderings_equal(sites1, sites2):@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    For two given lists of points test if they are @\\
\mbox{}\verb@    equal or not. We do this by checking the Linfinity@\\
\mbox{}\verb@    norm.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    for (x1,y1), (x2,y2) in zip(sites1, sites2): @\\
\mbox{}\verb@        if (x1-x2)**2 + (y1-y2)**2 > 1e-8:@\\
\mbox{}\verb@@\\
\mbox{}\verb@            print Fore.BLUE+ "Site Orderings are not equal"@\\
\mbox{}\verb@            print sites1@\\
\mbox{}\verb@            print sites2@\\
\mbox{}\verb@            print '-------------------------' + Style.RESET_ALL@\\
\mbox{}\verb@            return False@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return True@\\
\mbox{}\verb@        @\\
\mbox{}\verb@    print "\n\n\n\n---------------------"@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def bunch_of_random_points(numpts):@\\
\mbox{}\verb@    cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@    numcenters   = cluster_size@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    import scipy@\\
\mbox{}\verb@    import random@\\
\mbox{}\verb@    centers = scipy.rand(numcenters,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    scale = 4.0@\\
\mbox{}\verb@    points = []@\\
\mbox{}\verb@    for c in centers:@\\
\mbox{}\verb@        cx = c[0]@\\
\mbox{}\verb@        cy = c[1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sq_size      = min(cx,1-cx,cy, 1-cy)@\\
\mbox{}\verb@        cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@        loc_pts_x    = np.random.uniform(low=cx-sq_size/scale, @\\
\mbox{}\verb@                                         high=cx+sq_size/scale, @\\
\mbox{}\verb@                                         size=(cluster_size,))@\\
\mbox{}\verb@        loc_pts_y    = np.random.uniform(low=cy-sq_size/scale, @\\
\mbox{}\verb@                                         high=cy+sq_size/scale, @\\
\mbox{}\verb@                                         size=(cluster_size,))@\\
\mbox{}\verb@@\\
\mbox{}\verb@        points.extend(zip(loc_pts_x, loc_pts_y))@\\
\mbox{}\verb@@\\
\mbox{}\verb@    num_remaining_pts = numpts - cluster_size * numcenters@\\
\mbox{}\verb@@\\
\mbox{}\verb@    remaining_pts = scipy.rand(num_remaining_pts, 2).tolist()@\\
\mbox{}\verb@    points.extend(remaining_pts)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return points@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\chapter{Classic Horsefly}
\label{chap:classic-horsefly}

\section{Module Overview}

\newchunk 
All algorithms to solve the classic horsefly problems have been implemented in 
the file \verb|problem_classic_horsefly.py|. Here is a high-level view of the 
module. The \verb|run_handler| function acts as a kind of main function for this
module. This function is called from \verb|main.py| which then processes the 
command-line arguments and runs the experimental or interactive sections of
the code. 

\begin{flushleft} \small\label{scrap11}\raggedright\small
\NWtarget{nuweb24a}{} \verb@"../src/lib/problem_classic_horsefly.py"@\nobreak\ {\footnotesize {24a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Relevant imports for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb24b}{24b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@def run_handler():@\\
\mbox{}\verb@    @\hbox{$\langle\,${\itshape Define key-press handler}\nobreak\ {\footnotesize \NWlink{nuweb25}{25}}$\,\rangle$}\verb@@\\
\mbox{}\verb@    @\hbox{$\langle\,${\itshape Set up interactive canvas}\nobreak\ {\footnotesize \NWlink{nuweb28b}{28b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Local data-structures for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb29}{29}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb36a}{36a}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb31}{31}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Plotting routines for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb37}{37}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Module Details}

\newchunk 
\begin{flushleft} \small\label{scrap12}\raggedright\small
\NWtarget{nuweb24b}{} $\langle\,${\itshape Relevant imports for classic horsefly}\nobreak\ {\footnotesize {24b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@import utils_algo@\\
\mbox{}\verb@import utils_graphics@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk The key-press handler function detects the keys pressed by the user when the canvas
is in active focus. This function allows you to set some of the input parameters like 
speed ratio $\varphi$, or selecting an algorithm interactively at the command-line, 
generating a bunch of uniform or non-uniformly distributed points on the canvas, 
or just plain clearing the canvas for inserting a fresh input set of points. 


\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap13}\raggedright\small
\NWtarget{nuweb25}{} $\langle\,${\itshape Define key-press handler}\nobreak\ {\footnotesize {25}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@# The key-stack argument is mutable! I am using this hack to my advantage.@\\
\mbox{}\verb@def wrapperkeyPressHandler(fig,ax, run): @\\
\mbox{}\verb@       def _keyPressHandler(event):@\\
\mbox{}\verb@           if event.key in ['i', 'I']:  @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Start entering input from the command-line}\nobreak\ {\footnotesize \NWlink{nuweb26}{26}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           elif event.key in ['n', 'N', 'u', 'U']: @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Generate a bunch of uniform or non-uniform random points on the canvas}\nobreak\ {\footnotesize \NWlink{nuweb27}{27}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           elif event.key in ['c', 'C']: @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Clear canvas and states of all objects}\nobreak\ {\footnotesize \NWlink{nuweb28a}{28a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@       return _keyPressHandler@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\newchunk 
\begin{flushleft} \small\label{scrap14}\raggedright\small
\NWtarget{nuweb26}{} $\langle\,${\itshape Start entering input from the command-line}\nobreak\ {\footnotesize {26}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@phi_str = raw_input(Fore.YELLOW + \@\\
\mbox{}\verb@          "Enter speed of fly (should be >1): " +\@\\
\mbox{}\verb@           Style.RESET_ALL)@\\
\mbox{}\verb@phi = float(phi_str)@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_str = raw_input(Fore.YELLOW + \@\\
\mbox{}\verb@          "Enter algorithm to be used to compute the tour:\n Options are:\n" +\@\\
\mbox{}\verb@        "  (e)   Exact \n"                                   +\@\\
\mbox{}\verb@        "  (t)   TSP   \n"                                   +\@\\
\mbox{}\verb@        "  (tl)  TSP   (using approximate L1 ordering)\n"    +\@\\
\mbox{}\verb@        "  (k)   k2-center   \n"                             +\@\\
\mbox{}\verb@        "  (kl)  k2-center (using approximate L1 ordering)\n"  +\@\\
\mbox{}\verb@        "  (g)   Greedy\n"                                   +\@\\
\mbox{}\verb@        "  (gl) Greedy (using approximate L1 ordering])  "  +\@\\
\mbox{}\verb@        Style.RESET_ALL)@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_str = algo_str.lstrip()@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Incase there are patches present from the previous clustering, just clear them@\\
\mbox{}\verb@utils_graphics.clearAxPolygonPatches(ax)@\\
\mbox{}\verb@@\\
\mbox{}\verb@if   algo_str == 'e':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_dumb,@\\
\mbox{}\verb@                          phi )@\\
\mbox{}\verb@elif algo_str == 'k': @\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_kmeans,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          k=2,@\\
\mbox{}\verb@                          post_optimizer=algo_exact_given_specific_ordering)@\\
\mbox{}\verb@      print " "@\\
\mbox{}\verb@      print Fore.GREEN, answer['tour_points'], Style.RESET_ALL@\\
\mbox{}\verb@elif algo_str == 'kl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_kmeans,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          k=2,@\\
\mbox{}\verb@                          post_optimizer=algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 't':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_tsp_ordering,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer=algo_exact_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'tl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_tsp_ordering,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'g':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_greedy,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_exact_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'gl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_greedy,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@else:@\\
\mbox{}\verb@      print "Unknown option. No horsefly for you! ;-D "@\\
\mbox{}\verb@      sys.exit()@\\
\mbox{}\verb@@\\
\mbox{}\verb@#print horseflytour['tour_points']@\\
\mbox{}\verb@plotTour(ax,horseflytour, run.inithorseposn, phi, algo_str)@\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb25}{25}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk This chunk generates points uniformly or non-uniformly distributed in the 
unit square $[0,1]^2$ in the Matplotlib canvas. I will document the schemes used for generating the non-uniformly
distributed points later. These schemes are important to test the effectiveness of 
the horsefly algorithms. Uniform point clouds do no highlight the weaknesses of 
sequencing algorithms as David Johnson implies in his article on how to write 
experimental algorithm papers when he talks about algorithms for the TSP. 

\begin{flushleft} \small\label{scrap15}\raggedright\small
\NWtarget{nuweb27}{} $\langle\,${\itshape Generate a bunch of uniform or non-uniform random points on the canvas}\nobreak\ {\footnotesize {27}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@numpts = int(sys.argv[1]) @\\
\mbox{}\verb@run.clearAllStates()@\\
\mbox{}\verb@ax.cla()@\\
\mbox{}\verb@               @\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@                @\\
\mbox{}\verb@fig.texts = []@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@import scipy@\\
\mbox{}\verb@if event.key in ['n', 'N']: # Non-uniform random points@\\
\mbox{}\verb@        run.sites = utils_algo.bunch_of_random_points(numpts)@\\
\mbox{}\verb@else : # Uniform random points@\\
\mbox{}\verb@        run.sites = scipy.rand(numpts,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@patchSize  = (utils_graphics.xlim[1]-utils_graphics.xlim[0])/140.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@for site in run.sites:      @\\
\mbox{}\verb@    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \@\\
\mbox{}\verb@                 facecolor='blue',edgecolor='black' ))@\\
\mbox{}\verb@@\\
\mbox{}\verb@ax.set_title('Points : ' + str(len(run.sites)), fontdict={'fontsize':40})@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb25}{25}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk 

\begin{flushleft} \small\label{scrap16}\raggedright\small
\NWtarget{nuweb28a}{} $\langle\,${\itshape Clear canvas and states of all objects}\nobreak\ {\footnotesize {28a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@run.clearAllStates()@\\
\mbox{}\verb@ax.cla()@\\
\mbox{}\verb@              @\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@fig.texts = []@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb25}{25}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk 
\begin{flushleft} \small\label{scrap17}\raggedright\small
\NWtarget{nuweb28b}{} $\langle\,${\itshape Set up interactive canvas}\nobreak\ {\footnotesize {28b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@fig, ax =  plt.subplots()@\\
\mbox{}\verb@run = HorseFlyInput()@\\
\mbox{}\verb@#print run@\\
\mbox{}\verb@    @\\
\mbox{}\verb@ax.set_xlim([utils_graphics.xlim[0], utils_graphics.xlim[1]])@\\
\mbox{}\verb@ax.set_ylim([utils_graphics.ylim[0], utils_graphics.ylim[1]])@\\
\mbox{}\verb@ax.set_aspect(1.0)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@      @\\
\mbox{}\verb@mouseClick   = utils_graphics.wrapperEnterRunPoints (fig,ax, run)@\\
\mbox{}\verb@fig.canvas.mpl_connect('button_press_event' , mouseClick )@\\
\mbox{}\verb@      @\\
\mbox{}\verb@keyPress     = wrapperkeyPressHandler(fig,ax, run)@\\
\mbox{}\verb@fig.canvas.mpl_connect('key_press_event', keyPress   )@\\
\mbox{}\verb@plt.show()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Local Data Structures}


\newchunk This class manages the input and the output of the result of 
calling various horsefly algorithms. 

\begin{flushleft} \small\label{scrap18}\raggedright\small
\NWtarget{nuweb29}{} $\langle\,${\itshape Local data-structures for classic horsefly}\nobreak\ {\footnotesize {29}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@class HorseFlyInput:@\\
\mbox{}\verb@      def __init__(self, sites=[], inithorseposn=()):@\\
\mbox{}\verb@           self.sites         = sites@\\
\mbox{}\verb@           self.inithorseposn = inithorseposn@\\
\mbox{}\verb@@\\
\mbox{}\verb@           @\\
\mbox{}\verb@      def clearAllStates (self):@\\
\mbox{}\verb@          """ Set the sites to an empty list and initial horse position @\\
\mbox{}\verb@          to the empty tuple.@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@          self.sites = []@\\
\mbox{}\verb@          self.inithorseposn = ()@\\
\mbox{}\verb@@\\
\mbox{}\verb@          @\\
\mbox{}\verb@      def getTour(self, algo, speedratio, k=None, post_optimizer=None):@\\
\mbox{}\verb@          """ This method runs an appropriate algorithm for calculating@\\
\mbox{}\verb@          a horsefly tour. The list of possible algorithms are @\\
\mbox{}\verb@          inside this module prefixed with 'algo_'@\\
\mbox{}\verb@          @\\
\mbox{}\verb@          The output is a dictionary of size 2, containing two lists,@\\
\mbox{}\verb@          - Contains the vertices of the polygonal @\\
\mbox{}\verb@            path taken by the horse@\\
\mbox{}\verb@          - The list of sites in the order @\\
\mbox{}\verb@            in which they are serviced by the tour, i.e. the order @\\
\mbox{}\verb@            in which the sites are serviced by the fly.@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if k==None and post_optimizer==None:@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio)@\\
\mbox{}\verb@          elif k == None:@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio, post_optimizer)@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@                #print Fore.RED, self.sites, Style.RESET_ALL@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio, k, post_optimizer)@\\
\mbox{}\verb@          @\\
\mbox{}\verb@      def __repr__(self):@\\
\mbox{}\verb@          """ Printed Representation of the Input for HorseFly@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@          if self.sites != []:@\\
\mbox{}\verb@              tmp = ''@\\
\mbox{}\verb@              for site in self.sites:@\\
\mbox{}\verb@                  tmp = tmp + '\n' + str(site)@\\
\mbox{}\verb@              sites = "The list of sites to be serviced are " + tmp    @\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              sites = "The list of sites is empty"@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if self.inithorseposn != ():@\\
\mbox{}\verb@              inithorseposn = "\nThe initial position of the horse is " + \@\\
\mbox{}\verb@                               str(self.inithorseposn)@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              inithorseposn = "\nThe initial position of the horse has not been specified"@\\
\mbox{}\verb@              @\\
\mbox{}\verb@          return sites + inithorseposn@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
Now that all the boring boiler-plate and handler codes have been 
written, its finally time for algorithmic ideas and implementations! 
Every algorithm is given an algorithmic overview followed by the 
detailed steps woven together with the source code. 

Any local utility functions, needed for algorithmic or graphing purposes 
are collected at the end of this chapter. 

\newpage


\section{Algorithm: Greedy---Nearest Neighbor}  

\subsection{Algorithmic Overview}

\subsection{Algorithmic Details}
\begin{flushleft} \small\label{scrap19}\raggedright\small
\NWtarget{nuweb31}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {31}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def algo_greedy(sites, inithorseposn, phi, post_optimizer):@\\
\mbox{}\verb@      """@\\
\mbox{}\verb@      This implements the greedy algorithm for the canonical greedy@\\
\mbox{}\verb@      algorithm for collinear horsefly, and then uses the ordering @\\
\mbox{}\verb@      obtained to get the exact tour for that given ordering.@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      Many variations on this are possible. However, this algorithm@\\
\mbox{}\verb@      is simple and may be more amenable to theoretical analysis. @\\
\mbox{}\verb@      @\\
\mbox{}\verb@      We will need an inequality for collapsing chains however. @\\
\mbox{}\verb@      """@\\
\mbox{}\verb@      def next_rendezvous_point_for_horse_and_fly(horseposn, site):@\\
\mbox{}\verb@            """@\\
\mbox{}\verb@            Just use the exact solution when there is a single site. @\\
\mbox{}\verb@            No need to use the collinear horse formula which you can @\\
\mbox{}\verb@            explicitly derive. That formula is  an important super-special @\\
\mbox{}\verb@            case however to benchmark quality of solution. @\\
\mbox{}\verb@            """@\\
\mbox{}\verb@@\\
\mbox{}\verb@            horseflytour = algo_exact_given_specific_ordering([site], horseposn, phi)@\\
\mbox{}\verb@            return horseflytour['tour_points'][-1]@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      # Begin the recursion process where for a given initial@\\
\mbox{}\verb@      # position of horse and fly and a given collection of sites@\\
\mbox{}\verb@      # you find the nearst neighbor proceed according to segment@\\
\mbox{}\verb@      # horsefly formula for just and one site, and for the new@\\
\mbox{}\verb@      # position repeat the process for the remaining list of sites. @\\
\mbox{}\verb@      # The greedy approach can be extended to by finding the k@\\
\mbox{}\verb@      # nearest neighbors, constructing the exact horsefly tour@\\
\mbox{}\verb@      # there, at the exit point, you repeat by taking k nearest@\\
\mbox{}\verb@      # neighbors and so on. @\\
\mbox{}\verb@      def greedy(current_horse_posn, remaining_sites):@\\
\mbox{}\verb@            if len(remaining_sites) == 1:@\\
\mbox{}\verb@                  return remaining_sites@\\
\mbox{}\verb@            else:@\\
\mbox{}\verb@                  # For reference see this link on how nn queries are performed. @\\
\mbox{}\verb@                  # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html@\\
\mbox{}\verb@                  # Warning this is inefficient!!! I am rebuilding the @\\
\mbox{}\verb@                  # kd-tree at each step. Right now, I am only doing @\\
\mbox{}\verb@                  # this for convenience.@\\
\mbox{}\verb@                  from scipy import spatial@\\
\mbox{}\verb@                  tree = spatial.KDTree(remaining_sites)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  # The next site to get serviced by the drone and horse@\\
\mbox{}\verb@                  # is the one which is closest to the current position of the@\\
\mbox{}\verb@                  # horse. @\\
\mbox{}\verb@                  pts           = np.array([current_horse_posn])@\\
\mbox{}\verb@                  query_result  = tree.query(pts)@\\
\mbox{}\verb@                  next_site_idx = query_result[1][0]@\\
\mbox{}\verb@                  next_site     = remaining_sites[next_site_idx]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  next_horse_posn = \@\\
\mbox{}\verb@                        next_rendezvous_point_for_horse_and_fly(current_horse_posn, next_site)@\\
\mbox{}\verb@                  #print remaining_sites@\\
\mbox{}\verb@                  remaining_sites.pop(next_site_idx) # the pop method modifies the list in place. @\\
\mbox{}\verb@                  @\\
\mbox{}\verb@                  return [ next_site ] + greedy (current_horse_posn = next_horse_posn, \@\\
\mbox{}\verb@                                                 remaining_sites    = remaining_sites)@\\
\mbox{}\verb@@\\
\mbox{}\verb@      sites1 = sites[:]@\\
\mbox{}\verb@      sites_ordered_by_greedy = greedy(inithorseposn, remaining_sites=sites1)@\\
\mbox{}\verb@@\\
\mbox{}\verb@      # Use exact solver for the post optimizer step@\\
\mbox{}\verb@      answer = post_optimizer(sites_ordered_by_greedy, inithorseposn, phi)@\\
\mbox{}\verb@      return answer@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb31}{31}\NWlink{nuweb32}{, 32}\NWlink{nuweb35}{, 35}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk 

\begin{flushleft} \small\label{scrap20}\raggedright\small
\NWtarget{nuweb32}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {32}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@# ALGORITHMS FOR SINGLE HORSE SINGLE FLY SERVICING THE SITES IN THE GIVEN ORDER@\\
\mbox{}\verb@def algo_exact_given_specific_ordering (sites, horseflyinit, phi):@\\
\mbox{}\verb@    """ Use the *given* ordering of sites to compute a good tour @\\
\mbox{}\verb@    for the horse.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    def ith_leg_constraint(i, horseflyinit, phi, sites):@\\
\mbox{}\verb@        """ For the ith segment of the horsefly tour@\\
\mbox{}\verb@        this function returns a constraint function which @\\
\mbox{}\verb@        models the fact that the time taken by the fly @\\
\mbox{}\verb@        is equal to the time taken by the horse along @\\
\mbox{}\verb@        that particular segment.@\\
\mbox{}\verb@        """@\\
\mbox{}\verb@        if i == 0 :@\\
\mbox{}\verb@            def _constraint_function(x):@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                #print "Constraint  ", i@\\
\mbox{}\verb@                start = np.array (horseflyinit)@\\
\mbox{}\verb@                site  = np.array (sites[0])@\\
\mbox{}\verb@                stop  = np.array ([x[0],x[1]])@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                horsetime = np.linalg.norm( stop - start )@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                flytime_to_site   = 1/phi * np.linalg.norm( site - start )@\\
\mbox{}\verb@                flytime_from_site = 1/phi * np.linalg.norm( stop - site  )@\\
\mbox{}\verb@                flytime           = flytime_to_site + flytime_from_site@\\
\mbox{}\verb@                return horsetime-flytime@\\
\mbox{}\verb@@\\
\mbox{}\verb@            return _constraint_function@\\
\mbox{}\verb@        else :@\\
\mbox{}\verb@          @\\
\mbox{}\verb@            def _constraint_function(x):@\\
\mbox{}\verb@@\\
\mbox{}\verb@               #print "Constraint  ", i@\\
\mbox{}\verb@               start = np.array (  [x[2*i-2], x[2*i-1]]  ) @\\
\mbox{}\verb@               site  = np.array (  sites[i])@\\
\mbox{}\verb@               stop  = np.array (  [x[2*i]  , x[2*i+1]]  )@\\
\mbox{}\verb@            @\\
\mbox{}\verb@               horsetime = np.linalg.norm( stop - start )@\\
\mbox{}\verb@           @\\
\mbox{}\verb@               flytime_to_site   = 1/phi * np.linalg.norm( site - start )@\\
\mbox{}\verb@               flytime_from_site = 1/phi * np.linalg.norm( stop - site  )@\\
\mbox{}\verb@               flytime           = flytime_to_site + flytime_from_site@\\
\mbox{}\verb@               return horsetime-flytime@\\
\mbox{}\verb@@\\
\mbox{}\verb@            return _constraint_function@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    def generate_constraints(horseflyinit, phi, sites):@\\
\mbox{}\verb@        """ Given input data, of the problem generate the @\\
\mbox{}\verb@        constraint list for each leg of the tour. The number@\\
\mbox{}\verb@        of legs is equal to the number of sites for the case @\\
\mbox{}\verb@        of single horse, single drone@\\
\mbox{}\verb@        """@\\
\mbox{}\verb@        cons = []@\\
\mbox{}\verb@        for i in range(len(sites)):@\\
\mbox{}\verb@            cons.append( { 'type':'eq',@\\
\mbox{}\verb@                            'fun': ith_leg_constraint(i,horseflyinit,phi, sites) } )@\\
\mbox{}\verb@        return cons@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    cons = generate_constraints(horseflyinit, phi, sites)@\\
\mbox{}\verb@    # Since the horsely tour lies inside the square,@\\
\mbox{}\verb@    # the bounds for each coordinate is 0 and 1@\\
\mbox{}\verb@    #x0 = np.empty(2*len(sites))@\\
\mbox{}\verb@    #x0.fill(0.5) # choice of filling vector with 0.5 is arbitrary@\\
\mbox{}\verb@@\\
\mbox{}\verb@    x0 = utils_algo.flatten_list_of_lists(sites) # the initial choice is just the sites@\\
\mbox{}\verb@    assert(len(x0) == 2*len(sites))@\\
\mbox{}\verb@    x0 = np.array(x0)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    sol = minimize(tour_length(horseflyinit), x0, method= 'SLSQP', \@\\
\mbox{}\verb@                               constraints=cons, options={'maxiter':500})@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    tour_points = utils_algo.pointify_vector(sol.x)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # return the waiting times for the horse@\\
\mbox{}\verb@    numsites            = len(sites)@\\
\mbox{}\verb@    alpha               = horseflyinit[0]@\\
\mbox{}\verb@    beta                = horseflyinit[1]@\\
\mbox{}\verb@    s                   = utils_algo.flatten_list_of_lists(sites)@\\
\mbox{}\verb@    horse_waiting_times = np.zeros(numsites)@\\
\mbox{}\verb@    ps                  = sol.x@\\
\mbox{}\verb@    for i in range(numsites):@\\
\mbox{}\verb@        if i == 0 :@\\
\mbox{}\verb@            horse_time         = np.sqrt((ps[0]-alpha)**2 + (ps[1]-beta)**2)@\\
\mbox{}\verb@            fly_time_to_site   = 1.0/phi * np.sqrt((s[0]-alpha)**2 + (s[1]-beta)**2 )@\\
\mbox{}\verb@            fly_time_from_site = 1.0/phi * np.sqrt((s[0]-ps[1])**2 + (s[1]-ps[1])**2)@\\
\mbox{}\verb@        else:@\\
\mbox{}\verb@            horse_time         = np.sqrt((ps[2*i]-ps[2*i-2])**2 + (ps[2*i+1]-ps[2*i-1])**2)@\\
\mbox{}\verb@            fly_time_to_site   = 1.0/phi * np.sqrt(( (s[2*i]-ps[2*i-2])**2 + (s[2*i+1]-ps[2*i-1])**2 )) @\\
\mbox{}\verb@            fly_time_from_site = 1.0/phi * np.sqrt(( (s[2*i]-ps[2*i])**2   + (s[2*i+1]-ps[2*i+1])**2 )) @\\
\mbox{}\verb@@\\
\mbox{}\verb@        horse_waiting_times[i] = horse_time - (fly_time_to_site + fly_time_from_site)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return {'tour_points'                : tour_points,@\\
\mbox{}\verb@            'horse_waiting_times'        : horse_waiting_times, @\\
\mbox{}\verb@            'site_ordering'              : sites,@\\
\mbox{}\verb@            'tour_length_with_waiting_time_included': \@\\
\mbox{}\verb@                                       tour_length_with_waiting_time_included(\@\\
\mbox{}\verb@                                                    tour_points, \@\\
\mbox{}\verb@                                                    horse_waiting_times, @\\
\mbox{}\verb@                                                    horseflyinit)}@\\
\mbox{}\verb@   @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb31}{31}\NWlink{nuweb32}{, 32}\NWlink{nuweb35}{, 35}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Algorithm: Dumb Brute force}

\subsection{Algorithmic Overview}

\subsection{Algorithmic Details}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap21}\raggedright\small
\NWtarget{nuweb35}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {35}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def algo_dumb(sites, horseflyinit, phi):@\\
\mbox{}\verb@    """ For each of the n factorial ordering of sites@\\
\mbox{}\verb@    find the ordering which gives the smallest horsefly @\\
\mbox{}\verb@    tour length@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    tour_length_fn = tour_length(horseflyinit)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    best_tour = algo_exact_given_specific_ordering(sites, horseflyinit, phi)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    i = 0@\\
\mbox{}\verb@    for sites_perm in list(itertools.permutations(sites)):@\\
\mbox{}\verb@        print "Testing a new permutation ", i, " of the sites"; i = i + 1@\\
\mbox{}\verb@          @\\
\mbox{}\verb@        #tour_for_current_perm = algo_exact_given_specific_ordering (sites_perm, \@\\
\mbox{}\verb@                                                                     horseflyinit, phi) @\\
\mbox{}\verb@        tour_for_current_perm = algo_exact_given_specific_ordering (sites_perm, \@\\
\mbox{}\verb@                                                                    horseflyinit, phi) @\\
\mbox{}\verb@        if tour_length_fn(algo_utils.flatten_list_of_lists(tour_for_current_perm ['tour_points']) ) \@\\
\mbox{}\verb@         < tour_length_fn(algo_utils.flatten_list_of_lists(            best_tour ['tour_points']) ):@\\
\mbox{}\verb@                best_tour = tour_for_current_perm@\\
\mbox{}\verb@                @\\
\mbox{}\verb@                print Fore.RED + "Found better tour!" + Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    #print Fore.RED + "\nHorse Waiting times are ",\ @\\
\mbox{}\verb@    #       best_tour['horse_waiting_times'] , \@\\
\mbox{}\verb@    #       Style.RESET_ALL@\\
\mbox{}\verb@    return best_tour@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb31}{31}\NWlink{nuweb32}{, 32}\NWlink{nuweb35}{, 35}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Local Utility Functions}

\newchunk  For a given initial position of horse and fly
   return a function computing the tour length. 
   The returned function computes the tour length 
   in the order of the list of stops provided beginning 
   with the initial position of horse and fly. Since 
   the horse speed = 1, the tour length = time taken 
   by horse to traverse the route.

   This is in other words the objective function. 

\begin{flushleft} \small\label{scrap22}\raggedright\small
\NWtarget{nuweb36a}{} $\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize {36a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def tour_length(horseflyinit):@\\
\mbox{}\verb@   def _tourlength (x):@\\
\mbox{}\verb@         @\\
\mbox{}\verb@        # the first point on the tour is the@\\
\mbox{}\verb@        # initial position of horse and fly@\\
\mbox{}\verb@        # Append this to the solution x = [x0,x1,x2,....]@\\
\mbox{}\verb@        # at the front@\\
\mbox{}\verb@        htour = np.append(horseflyinit, x)@\\
\mbox{}\verb@        length = 0 @\\
\mbox{}\verb@@\\
\mbox{}\verb@        for i in range(len(htour))[:-3:2]:@\\
\mbox{}\verb@                length = length + \@\\
\mbox{}\verb@                         np.linalg.norm([htour[i+2] - htour[i], \@\\
\mbox{}\verb@                                         htour[i+3] - htour[i+1]]) @\\
\mbox{}\verb@        return length@\\
\mbox{}\verb@@\\
\mbox{}\verb@   return _tourlength@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb36a}{36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk It is possible that some heuristics might return non-negligible
      waiting times. Hence I am writing a separate function which
      adds the waiting time (if it is positive) to the length of 
      each link of the tour. Again note that because 
      speed of horse = 1, we can add ``time'' to ``distance''. 

\begin{flushleft} \small\label{scrap23}\raggedright\small
\NWtarget{nuweb36b}{} $\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize {36b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def tour_length_with_waiting_time_included(tour_points, horse_waiting_times, horseflyinit):@\\
\mbox{}\verb@      tour_points   = np.asarray([horseflyinit] + tour_points)@\\
\mbox{}\verb@      tour_links    = zip(tour_points, tour_points[1:])@\\
\mbox{}\verb@@\\
\mbox{}\verb@      # the +1 because the inital position has been tacked on at the beginning@\\
\mbox{}\verb@      # the solvers written the tour points except for the starting position@\\
\mbox{}\verb@      # because that is known and part of the input. For this function@\\
\mbox{}\verb@      # I need to tack it on for tour length@\\
\mbox{}\verb@      assert(len(tour_points) == len(horse_waiting_times)+1) @\\
\mbox{}\verb@@\\
\mbox{}\verb@      sum = 0@\\
\mbox{}\verb@      for i in range(len(horse_waiting_times)):@\\
\mbox{}\verb@@\\
\mbox{}\verb@          # Negative waiting times means drone/fly was waiting@\\
\mbox{}\verb@          # at rendezvous point@\\
\mbox{}\verb@          if horse_waiting_times[i] >= 0:@\\
\mbox{}\verb@              wait = horse_waiting_times[i]@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              wait = 0@\\
\mbox{}\verb@              @\\
\mbox{}\verb@          sum += wait + np.linalg.norm(tour_links[i][0] - tour_links[i][1], ord=2) # @\\
\mbox{}\verb@      return sum@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb36a}{36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Plotting Routines}
\newchunk 

\begin{flushleft} \small\label{scrap24}\raggedright\small
\NWtarget{nuweb37}{} $\langle\,${\itshape Plotting routines for classic horsefly}\nobreak\ {\footnotesize {37}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@ @\\
\mbox{}\verb@def plotTour(ax,horseflytour, horseflyinit, phi, algo_str, tour_color='#d13131'):@\\
\mbox{}\verb@    """ Plot the tour on the given canvas area@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@   @\\
\mbox{}\verb@    # Route for the horse@\\
\mbox{}\verb@    xhs, yhs = [horseflyinit[0]], [horseflyinit[1]]@\\
\mbox{}\verb@    for pt in horseflytour['tour_points']:@\\
\mbox{}\verb@        xhs.append(pt[0])@\\
\mbox{}\verb@        yhs.append(pt[1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # List of sites@\\
\mbox{}\verb@    xsites, ysites = [], []@\\
\mbox{}\verb@    for pt in horseflytour['site_ordering']:@\\
\mbox{}\verb@        xsites.append(pt[0])@\\
\mbox{}\verb@        ysites.append(pt[1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Route for the fly. The fly keeps alternating@\\
\mbox{}\verb@    # between the site and the horse@\\
\mbox{}\verb@    xfs , yfs = [xhs[0]], [yhs[0]]@\\
\mbox{}\verb@    for site, pt in zip (horseflytour['site_ordering'],@\\
\mbox{}\verb@                         horseflytour['tour_points']):@\\
\mbox{}\verb@        xfs.extend([site[0], pt[0]])@\\
\mbox{}\verb@        yfs.extend([site[1], pt[1]])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "\n----------"@\\
\mbox{}\verb@    print "Horse Tour"@\\
\mbox{}\verb@    print "-----------"@\\
\mbox{}\verb@    waiting_times = [0.0] + horseflytour['horse_waiting_times'].tolist() # the waiting time at the starting point is 0@\\
\mbox{}\verb@    #print waiting_times@\\
\mbox{}\verb@    for pt, time in zip(zip(xhs,yhs), waiting_times) :@\\
\mbox{}\verb@        print pt, Fore.GREEN, " ---> Horse Waited ", time, Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "\n----------"@\\
\mbox{}\verb@    print "Fly Tour"@\\
\mbox{}\verb@    print "----------"@\\
\mbox{}\verb@    for item, i in zip(zip(xfs,yfs), range(len(xfs))):@\\
\mbox{}\verb@        if i%2 == 0:@\\
\mbox{}\verb@           print item@\\
\mbox{}\verb@        else :@\\
\mbox{}\verb@           print Fore.RED + str(item) + "----> Site" +  Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "----------------------------------"@\\
\mbox{}\verb@    print Fore.GREEN, "\nSpeed of the drone was set to be", phi@\\
\mbox{}\verb@    #tour_length = utils_algo.length_polygonal_chain( zip(xhs, yhs))@\\
\mbox{}\verb@    tour_length = horseflytour['tour_length_with_waiting_time_included']@\\
\mbox{}\verb@    print "Tour length of the horse is ",  tour_length@\\
\mbox{}\verb@    print "Algorithm code-Key used "    , algo_str, Style.RESET_ALL@\\
\mbox{}\verb@    print "----------------------------------\n"@\\
\mbox{}\verb@           @\\
\mbox{}\verb@    #kwargs = {'size':'large'}@\\
\mbox{}\verb@    for x,y,i in zip(xsites, ysites, range(len(xsites))):@\\
\mbox{}\verb@          ax.text(x, y, str(i+1), bbox=dict(facecolor='#ddcba0', alpha=1.0)) @\\
\mbox{}\verb@    ax.plot(xfs,yfs,'g-') # fly tour is green@\\
\mbox{}\verb@    ax.plot(xhs, yhs, color=tour_color, marker='s', linewidth=3.0) # horse is red@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Initial position of horse and fly@\\
\mbox{}\verb@    ax.add_patch( mpl.patches.Circle( horseflyinit,@\\
\mbox{}\verb@                                      radius = 1/34.0,@\\
\mbox{}\verb@                                      facecolor= '#D13131', #'red',@\\
\mbox{}\verb@                                      edgecolor='black'   )  )@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    fontsize = 10@\\
\mbox{}\verb@    tnrfont = {'fontname':'Times New Roman'}@\\
\mbox{}\verb@    ax.set_title(  'Algorithm Used: ' + algo_str +  '\nTour Length: ' \@\\
\mbox{}\verb@                    + str(tour_length)[:7], fontdict={'fontsize':fontsize}, **tnrfont)@\\
\mbox{}\verb@    ax.set_xlabel('Number of sites: ' + str(len(xsites)) + '\nDrone Speed: ' + str(phi) ,@\\
\mbox{}\verb@                  fontdict={'fontsize':fontsize}, **tnrfont)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb24a}{24a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\chapter{Segment Horsefly}
\label{chap:segment-horsefly}\chapter{Fixed Route Horsefly}
\label{chap:fixed-route-horsefly}\chapter{One Horse, Two Flies}
\label{chap:one-horse-two-flies}
\chapter{Reverse Horsefly}
\label{chap:reverse-horsefly}\chapter{Watchman Horsefly}
\label{watchman-horsefly}




\begin{appendices}
\chapter{Index of Files}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \verb@"../main.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb13}{13}.}
\item \verb@"../src/lib/problem_classic_horsefly.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb24a}{24a}.}
\item \verb@"../src/lib/utils_algo.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb19}{19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21a}{, 21a}\NWlink{nuweb21b}{b}.
}
\item \verb@"../src/lib/utils_graphics.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb15}{15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17a}{, 17a}\NWlink{nuweb17b}{b}.
}
\end{list}}
\chapter{Index of Fragments}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item $\langle\,$Algorithms for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb31}{31}\NWlink{nuweb32}{, 32}\NWlink{nuweb35}{, 35}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Clear canvas and states of all objects\nobreak\ {\footnotesize \NWlink{nuweb28a}{28a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb25}{25}.}
\item $\langle\,$Define key-press handler\nobreak\ {\footnotesize \NWlink{nuweb25}{25}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Generate a bunch of uniform or non-uniform random points on the canvas\nobreak\ {\footnotesize \NWlink{nuweb27}{27}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb25}{25}.}
\item $\langle\,$Local data-structures for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb29}{29}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Local utility functions for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb36a}{36a}\NWlink{nuweb36b}{b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Plotting routines for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb37}{37}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Relevant imports for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb24b}{24b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Set up interactive canvas\nobreak\ {\footnotesize \NWlink{nuweb28b}{28b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb24a}{24a}.}
\item $\langle\,$Start entering input from the command-line\nobreak\ {\footnotesize \NWlink{nuweb26}{26}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb25}{25}.}
\end{list}}
\chapter{Index of Identifiers}
 
\chapter{Man-page for \texttt{main.py}}
\end{appendices}

\end{document}
