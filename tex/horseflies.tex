\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
\documentclass[11.5pt]{report}
\input{standard_settings.tex}

%%% Super useful for marking todo notes, ripped from here: 
%%% https://tex.stackexchange.com/a/178806/17858
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\UNSURE}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\TODO}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}

\usepackage{kantlipsum}
\usepackage{fancyvrb}
\usepackage{setspace}
\newenvironment{CVerbatim}
 {\singlespacing\center\BVerbatim}
 {\endBVerbatim\endcenter}



\usepackage{tocloft}
\renewcommand{\cftpartfont}{\LARGE\itshape} % Part title in Huge Italic font
\usepackage{hyperref}
\usepackage{etoolbox}
% Better formatting of backticks in 
% verbatim environment. 
\usepackage{upquote}

% page numbering at top right
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

\begin{document}
\begin{titlepage}
	\centering
        {\Huge Experimental Analyses of Heuristics for Horsefly-type Problems\\}
        \vspace{20mm}
        {\Large Gaurish Telang}
\end{titlepage}
% This gives the titlepage the page number of 1, 
% making it easier to navigate with a pdfviewer
% such as zathura, which seems to only be able 
% to understand page-numbers beginning from 1. 
\pagenumbering{arabic}
\setcounter{page}{2} 

% For global table of contents
\setcounter{tocdepth}{1}
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\part{Overview}
\chapter{Descriptions of Problems}
\label{chap:descriptions-of-problems}


\begin{figure}[H]
  \centering

  \includegraphics[width=8cm]{../webs/docs/prelim_example_phi5.png}
  \caption{An Example of a classic Horsefly tour with $\varphi=5$. The red dot
    indicates the initial position of the horse and fly, given as part of 
    the input. The ordering of sites shown has been computed with a greedy 
    algorithm which will be described later}
  \label{fig:prelim-example}
\end{figure}


The Horsefly problem is a generalization of the well-known Euclidean Traveling Salesman Problem.
In the most basic version of the Horsefly problem (which we call \textbf{``Classic Horsefly''}), we are given a set of sites, the
initial position of a truck(horse) with a drone(fly) mounted on top, and the speed of the
drone-speed $\varphi$. \footnote{ The speed of the truck is always assumed to be 1 in any of the problem 
  variations we will be considering in this report.} \footnote{ $\varphi$ is also called the ``speed ratio''.}. 

The goal is to compute a tour for both the truck and the drone to deliver package to sites
as quickly as possible. For delivery, a drone must pick up a package from the
truck, fly to the site and come back to the truck to pick up the next package for
delivery to another site. \footnote{ The drone is assumed to be able to carry at most one package at a time }
Both the truck and drone must coordinate their motions to minimize the time it takes for
all the sites to get their packages. Figure \ref{fig:prelim-example} gives an example of such a tour
computed using a greedy heuristic for $\varphi=5$.


This suite of programs implement several experimental heuristics, to solve the above NP-hard
problem and some of its variations approximately. In this short chapter, we give a description 
of the problem variations that we will be tackling. Each of the problems, has a corresponding chapter 
in Part 2, where these heuristics are described and implemented. We also give comparative analyses of 
their experimental performance on various problem instances. 

\vspace{0.5cm}

\begin{description}
\item[Classic Horsefly] This problem has already described in the introduction.

\item[Segment Horsefly] In this variation, the path of the truck is restricted to that of a segment, 
  which we can consider without loss of generality to be $[0,1]$. All sites, without loss of generality 
  lie in the upper-half plane $\RR^2_{+}$. 

\item[Fixed Route Horsefly] This is the obvious generalization of Segment Horsefly, where the path
  which the truck is restricted to travel is a piece-wise linear polygonal path. 
  \footnote{More generally, the truck will be restricted to travelling on a road network, which would 
    typically be modelled as a graph embedded in the plane.} Both the initial 
  position of the truck and the drone are given. The sites to be serviced are allowed to lie anywhere in $\RR^2$. 
  Two further variations are possible in this setting, one in which the truck is allowed reversals
  and the other in which it is not. 

\item[One Horse, Two Flies] The truck is now equipped with two drones. Otherwise the setting, is exactly 
  the same as in classic horsefly. Each drone can carry only one package at a time. The drones must fly back
  and forth between the truck and the sites to deliver the packages. We allow the possibility that 
  both the drones can land at the same time and place on the truck to pick up their next package. \footnote{In reality, 
    one of the drones will have to wait for a small amount of time while the other is retrieving its package. 
    In a more realisting model, we would need to take into account this ``waiting time'' too.}

\item[Reverse Horsefly] In this model, each site (not the truck!) is equipped with a drone, which fly 
  \textit{towards} the truck to pick up their packages. We need to coordinate the motion of the truck 
  and drone so that the time it takes for the last drone to pick up its package (the ``makespan'') is 
  minimized. 

\item[Bounded Distance Horsefly] In most real-world scenarios, the drone will not be able to (or allowed to) go more than
  a certain distance $R$ from the truck. Thus with the same settings as the classic horsefly, but with the added 
  constraint of the drone and the truck never being more than a distance $R$ from the truck, how would one 
  compute the truck and drone paths to minimize the makespan of the deliveries? 

\item[Watchman Horsefly] In place of the TSP, we generalize the Watchman route problem here. 
  \footnote{ although abstractly, the Watchman route problem can be viewed as a kind of TSP}
  We are given as input a simple polygon and the initial position of a truck and a drone. The drone has 
  a camera mounted on top which is assumed to have $360^{\circ}$ vision. Both the truck and drone can move, 
  but the drone can move at most euclidean distance \footnote{The version where instead geodesic distance is 
    considered is also interesting} $R$ from the truck. 

  We want every point in the polygon to be seen by the drone at least once. The goal is to minimize the time it 
  takes for the drone to be able to see every point in the simple polygon. In other words, we want to minimize
  the time it takes for the drone (moving in coordinattion with the truck) to patrol the entire polygon. 
  
\end{description}

\chapter{Installation and Use}

To run these programs you will need to install Docker, an open-source containerization program that is easily installable on 
  Windows 10\footnote{You might need to turn on virtualization explicitly in your BIOS, after installing Docker 
  as I needed to while setting Docker up on Windows. Here is a snapshot of an image when turning on Intel's 
  virtualization technology through the BIOS: 
\url{https://images.techhive.com/images/article/2015/09/virtualbox_vt-x_amd-v_error04_phoenix-100612961-large.idge.jpg}}, MacOS, and almost any 
  GNU/Linux distribution. For a quick introduction to containerization, watch the first two minutes of 
  \url{https://youtu.be/_dfLOzuIg2o}

The nice thing about Docker is that it makes it easy to run softwares on different OS'es portably and neatly side-steps the 
dependency hell problem (\url{https://en.wikipedia.org/wiki/Dependency_hell}.) The headache of installing different library 
dependencies correctly on different machines running different OS'es, is replaced \textbf{only} by learning how to 
install Docker and to set up an X-windows connection between the host OS and an instantiated container running GNU/Linux. 

\begin{alphalist}
\item \crunchy{Get Docker} For installation instrutions watch
  \begin{description}
    \item[GNU/Linux]  \url{https://youtu.be/KCckWweNSrM}
    \item[Windows]    \url{https://youtu.be/ymlWt1MqURY}
    %\item[MacOS]      \url{https://youtu.be/MU8HUVlJTEY}
  \end{description}
  To test your installation, run the \verb|hello-world| container. Note that you might 
  need administrator privileges to run docker. On Windows, you can open the Powershell 
  as an administrator. On GNU/Linux you should use \verb|sudo|
\item \crunchy{Download customized Ubuntu image} \verb| docker pull gtelang/ubuntu_customized| \footnote{The customized Ubuntu image is approximately
  7 GB which contains all the libraries (e.g. CGAL, VTK, numpy, and matplotlib) that I typically use to run 
  my research codes portably.On my home internet connection downloading this Ubuntu-image typically takes about 5-10 minutes. }
\item \crunchy{Clone repository} \verb|git clone gtelang/horseflies_literate.git|
\item \crunchy{Mount and Launch} 
\begin{description}
\item[If you are running GNU/Linux] 
\begin{itemize}
   \item Open up your favorite terminal emulator, such as xterm, rxvt or konsole
   \item Copy to clipboard the output of \texttt{xauth list}
   \item \verb|cd horseflies_literate|
   \item \texttt{docker run -it -\phantom{}-name horsefly\_container -\phantom{}-net=host \textbackslash \newline 
                -e DISPLAY -v /tmp/.X11-unix \textbackslash                                              \newline 
                -v  \`{}pwd\`{}:/horseflies\_mnt gtelang/ubuntu\_customized}
   \item \verb|cd horseflies_mnt| 
   \item \verb|xauth add | \textit{<paste-from-clipboard>}
\end{itemize}

The purpose of using  ``\verb|xauth|'' and ``\verb|-e DISPLAY -v /tmp/.X11-unix|'' is to establish an X-windows connection between your operating 
system and the Ubuntu container that allows you to run GUI apps e.g. the FireFox web-browser. 
\footnote{I found the instructions for running GUI apps on containers in \url{https://www.youtube.com/watch?v=RDg6TRwiPtg}}

\item[If you are running Windows]
  \begin{itemize}
    \item Follow every instruction in \url{https://dev.to/darksmile92/run-gui-app-in-linux-Docker-container-on-windows-host-4kde}.
    \footnote{This step is necessary displaying the Matplotlib canvas as we do in the horseflies project for interactive testing of algorithms.}
      Make sure you can run a gui program like the Firefox web-browser as indicated by the article before going to the next step. 

    \item To mount the horseflies folder, you need to \textit{share} the appropriate drive (e.g. \verb|C:\| or \verb|D:\|) that the \verb|horseflies| folder is in with Docker.
      Follow instructions here: \url{https://rominirani.com/docker-on-windows-mounting-host-directories-d96f3f056a2c}
      for sharing directories. \footnote{you might need administrator privileges to perform this step, as pointed out by the article.}

    \item Open up a Windows Powershell (possibly as administrator)
      \begin{itemize}
           \item \verb|set-variable -name DISPLAY -value <your-ip-address>:0.0| \footnote{You can find your ip-address by the output of the \texttt{ipconfig} command in the Powershell}
           \item \verb|docker run -ti --rm -e DISPLAY=$DISPLAY -v <location-of-horseflies-folder>:/horseflies_mnt  gtelang/ubuntu_customized|
      \end{itemize}
  \end{itemize}

\end{description}

\item \crunchy{Run experiments} If you want to run all the experiments as described in 
  the paper again to reproduce the reported results on your machine, then run \footnote{ Allowing, of course,
  for differences between your machine's CPU and mine when it comes to reporting absolute running time}, \\
  \verb|python main.py --run-all-experiments|. 

  If you want to run a specific experiment, then run \\ \verb|python main.py --run-experiment <experiment-name>|. 

  See Index for a list of all the experiments. 

\item \crunchy{Test algorithms interactively}  If you want to test the algorithms in interactive mode 
  (where you get to select the problem-type, mouse-in the sites on a canvas, set the initial position of 
  the truck and drone and set $\varphi$), run \verb|python main.py --<problem-name>|. The
  list of problems are the same as that given in the previous chapter. The problem name consists
  of all lower-case letters with spaces replaced by hyphens. 

  Thus for instance ``Watchman Horsefly'' becomes \verb|watchman-horsefly| and ``One Horse Two Flies''
  becomes \verb|one-horse-two-flies|. 

  To interactively experiment with different algorithms for, say, the Watchman Horsefly problem , 
  type at the terminal \verb|python main.py --watchman-horsefly|
\end{alphalist}

\vspace{1cm}

If you want to delete the Ubuntu image and any associated containers run the command \footnote{the ubuntu image is 7GB afterall!}
\begin{verbatim}
 docker rm -f horsefly_container; docker rmi -f ubuntu_customized
\end{verbatim}

That's it! Happy horseflying!
\part{Programs}
\chapter{Overview of the Code Base}

All of the code has been written in Python 2.7 and tested using the standard CPython
implementation of the language. In some cases, calls will be made to external C\texttt{++} 
libraries (mostly CGAL and VTK) using SWIG (\url{http://www.swig.org/})
for speeding up a slow routine or to use a function that is not available in any existing 
Python package.

\section{Source Tree}
\input{directory-tree.tex}

There are three principal directories 
\begin{itemize}

 \item[\texttt{webs/}] This contains the source code for the entire project written in 
                       the nuweb format along with documents (mostly images)
                       needed during the compilation of the \LaTeX{} files which will 
                       be extracted from the \texttt{.web} files. 

 \item[\texttt{src/}] This contains the source code for the entire project ``tangled'' 
                      (i.e. extracted) from the \texttt{.web} files. 
 \item[\texttt{tex/}] This contains the monolithic \texttt{horseflies.tex} extracted 
                      from the \texttt{.web} files and a bunch 
                      of other supporing \LaTeX{} files. It also contains the final 
                      compiled \texttt{horseflies.pdf} (the current document) which 
                      contains the documentation of the project, interwoven with 
                      code-chunks and cross-references between them along with the 
                      experimental results.  
\end{itemize}  

The files in \texttt{src} and \texttt{tex} should not be touched. Any editing required should 
be done directly to the \texttt{.web} files which should then be weaved and tangled 
using \texttt{weave-tangle.sh}. 

\section{The Main Files} 

\newchunk 
\begin{alphalist}

\item \crunchy{\texttt{main.py}} The file \verb|main.py| in the top-level folder is the 
\textit{entry-point} for running code. Its only job is to parse the 
command-line arguments and pass relevant information to the handler 
functions for each problem and experiment. 

\item \crunchy{Algorithmic Code} All such files are in the directory \texttt{src/lib/}.
  Each of the files with prefix ``\verb|problem_*|'' contain implmentations of 
  algorithms for one specific problem. For instance \verb|problem_watchman_horsefly.py| 
  contains algorithms for approximately solving the Watchman Horsefly problem. 
 
  Since Horsefly-type problems are typically NP-hard, an important factor in 
  the subsequent experimental analysis will require, comparing an algorithm's  
  output against good lower bounds. Each such file, will also have routines
  for efficiently computing or approximating various lower-bounds for the 
  corresponding problem's \textit{OPT}. 

\item \crunchy{Experiments} All such files are in the directory \texttt{src/expt/}
 Each of the files with prefix ``\verb|expt_*|'' 
 contain code for testing hypotheses regarding a problem, generating 
 counter-examples or comparing the experimental performance of the 
 algorithm implementations for each of the problems. Thus 
 \verb|expt_watchman_horsefly.py| contains 
 code for performing experiments related to the 
 Watchman Horsefly problem. 
\end{alphalist}


If you need to edit the source-code for algorithms or experiment 
you should do so to the \texttt{.web} files in the web directory. Every problem
has a dedicated \textit{folder} containing source-code for algorithms and experiments 
pertaining to that problem. Every algorithm and experiment has a dedicated \verb|.web|
file in these problem directories. Such files are all ``tied'' together using the 
file with prefix \verb|problem-<problem-name>| in that same directory (i.e.
the file acts as a kind of handler for each problem, that includes the algorithms
and experiment \verb|web| files with the \verb|@i| macro.) 


\newchunk Let's define the \verb|main.py| file now. 

Each problem or experiment has a handler routine 
that effectively acts as a kind of ``main'' function for that module that 
does house-keeping duties by parsing the command-line arguments passed by main, 
setting up the canvas by calling the appropriate graphics routines and calling 
the algorithms on the input specified through the canvas. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap1}\raggedright\small
\NWtarget{nuweb12a}{} \verb@"../main.py"@\nobreak\ {\footnotesize {12a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Turn off Matplotlib's irritating DEBUG messages}\nobreak\ {\footnotesize \NWlink{nuweb12b}{12b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Import problem module files}\nobreak\ {\footnotesize \NWlink{nuweb12c}{12c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@if __name__=="__main__":@\\
\mbox{}\verb@     # Select algorithm or experiment @\\
\mbox{}\verb@     if (len(sys.argv)==1):@\\
\mbox{}\verb@          print "Specify the problem or experiment you want to run"@\\
\mbox{}\verb@          sys.exit()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-classic-horsefly":@\\
\mbox{}\verb@          chf.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-segment-horsefly":@\\
\mbox{}\verb@          shf.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     elif sys.argv[1] == "--problem-one-horse-two-flies":@\\
\mbox{}\verb@          oh2f.run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@     else:@\\
\mbox{}\verb@          print "Option not recognized"@\\
\mbox{}\verb@          sys.exit()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\newchunk On my customized Ubuntu container, Matplotlib produces tons of DEBUG log messages because  
it recently switched to the \verb|logging| library for...well...logging. 
The lines in this chunk were suggested by the link \url{http://matplotlib.1069221.n5.nabble.com/How-to-turn-off-matplotlib-DEBUG-msgs-td48822.html} 
for quietening down Matplotlib.  


\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap2}\raggedright\small
\NWtarget{nuweb12b}{} $\langle\,${\itshape Turn off Matplotlib's irritating DEBUG messages}\nobreak\ {\footnotesize {12b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@import logging@\\
\mbox{}\verb@mpl_logger = logging.getLogger('matplotlib')@\\
\mbox{}\verb@mpl_logger.setLevel(logging.WARNING)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb12a}{12a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap3}\raggedright\small
\NWtarget{nuweb12c}{} $\langle\,${\itshape Import problem module files}\nobreak\ {\footnotesize {12c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@sys.path.append('src/lib')@\\
\mbox{}\verb@import problem_classic_horsefly as chf@\\
\mbox{}\verb@#import problem_segment_horsefly as shf@\\
\mbox{}\verb@#import problem_one_horse_two_flies as oh2f@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb12a}{12a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Support Files}

\begin{alphalist}
\item \crunchy{Utility Files}  All such utility files are in the directory \texttt{src/lib/}. 
 These files contain common utility functions  for manipulating data-structures, plotting 
 and graphics routines common to all horsefly-type problems. All such files have the prefix 
 \verb|utils_*|. These Python files are generated from the single \verb|.web| file \verb|utils.web| 
 in the \verb|web| subdirectory.

\item \crunchy{Tests} All such files are in the directory \texttt{src/test/}
 To automate testing of code during implementations, tests for various 
 routines across the entire code-base have been written in files with prefix
 \verb|test_*|.  
 
 Every problem, utility, and experimental files in \verb|src/lib| and \verb|src/expts| 
 has a corresponding test-file in this folder. 
\end{alphalist}\chapter{Some (Boring) Utility Functions}
\label{chap:utility-functions}

We will be needing some utility functions, for drawing and manipulating data-structures 
which will be implemented in files separate from \verb|problem_classic_horsefly.py|.  All such
files will be prefixed with the work \verb|utils_|. Many of the important common utility 
functions are defined here; others will be defined on the fly throughout the rest of the report. 
This chapter just collects the most important of the functions for the sake of clarity of exposition
in the later chapters. 

\section{Graphical Utilities}

Here We will  develop routines to interactively insert points onto a Matplotlib canvas and clear the canvas. 
Almost all variants of the horsefly problem will involve mousing in sites and the initial position of the horse 
and fly. These points will typically be represented by small circular patches. The type of the point
will be indicated by its color and size e.g. intial position of truck and drone 
will typically be represented by a large red dot while and the sites by smaller blue dots. 

Matplotlib has extensive support for inserting such circular patches onto its canvas with 
mouse-clicks. Each such graphical canvas corresponds (roughly) to Matplotlib figure
object instance. Each figure consists of several Axes objects which contains
most of the figure elements i.e. the Axes objects correspond to the ``drawing area''
of the canvas. 

\newchunk First we set up the axes limits, dimensions and other configuration quantities
which will correspond to the ``without loss of generality'' assumptions made in the 
statements of the horsefly problems. We also need to set up the axes limits,
dimensions, and other fluff. The following fragment defines a function which 
``normalizes'' a drawing area by setting up the x and y limits and making the 
aspect ratio of the axes object the same i.e. 1.0. Since Matplotlib is principally
a plotting software, this is not the default behavior, since scales on the x and y 
axes are adjusted according to the data to be plotted. 

\begin{flushleft} \small\label{scrap4}\raggedright\small
\NWtarget{nuweb14}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {14}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@@\\
\mbox{}\verb@xlim, ylim = [0,1], [0,1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@def applyAxCorrection(ax):@\\
\mbox{}\verb@      ax.set_xlim([xlim[0], xlim[1]])@\\
\mbox{}\verb@      ax.set_ylim([ylim[0], ylim[1]])@\\
\mbox{}\verb@      ax.set_aspect(1.0)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15a}{, 15a}\NWlink{nuweb15b}{b}\NWlink{nuweb16}{, 16}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Next, given an axes object (i.e. a drawing area on a figure object) we need a function
to delete and remove all the graphical objects drawn on it. 

\begin{flushleft} \small\label{scrap5}\raggedright\small
\NWtarget{nuweb15a}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {15a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def clearPatches(ax):@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Remove line patches. These get inserted during the r=2 case,@\\
\mbox{}\verb@    # For some strange reason matplotlib does not consider line objects@\\
\mbox{}\verb@    # as patches.@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    #pp.pprint (ax.patches) # To verify that none of the patches are@\\
\mbox{}\verb@    # polyon patches corresponding to clusters.@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15a}{, 15a}\NWlink{nuweb15b}{b}\NWlink{nuweb16}{, 16}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Now remove the patches which were rendered for each cluster
    Unfortunately, this step has to be done manually, the canvas patch
    of a cluster and the corresponding object in memory are not reactively
    connected.I presume, this behavioue can be achieved by sub-classing.

\begin{flushleft} \small\label{scrap6}\raggedright\small
\NWtarget{nuweb15b}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {15b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def clearAxPolygonPatches(ax):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Remove line patches. These get inserted during the r=2 case,@\\
\mbox{}\verb@    # For some strange reason matplotlib does not consider line objects@\\
\mbox{}\verb@    # as patches.@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # To verify that none of the patches @\\
\mbox{}\verb@    # are polyon patches corresponding @\\
\mbox{}\verb@    # to clusters.@\\
\mbox{}\verb@    #pp.pprint (ax.patches) @\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15a}{, 15a}\NWlink{nuweb15b}{b}\NWlink{nuweb16}{, 16}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Now for one of the most important routines for drawing on the canvas! 
To insert the sites, we double-click the left mouse button and to insert the 
initial position of the horse and fly we double-click the right mouse-button. 

Note that the left mouse-button corresponds to button 1 and right mouse button
to button 3 in the code-fragment below. 

\begin{flushleft} \small\label{scrap7}\raggedright\small
\NWtarget{nuweb16}{} \verb@"../src/lib/utils_graphics.py"@\nobreak\ {\footnotesize {16}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@## Also modify to enter initial position of horse and fly@\\
\mbox{}\verb@def wrapperEnterRunPoints(fig, ax, run):@\\
\mbox{}\verb@    """ Create a closure for the mouseClick event.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    def _enterPoints(event):@\\
\mbox{}\verb@        if event.name     == 'button_press_event'      and \@\\
\mbox{}\verb@           (event.button   == 1 or event.button == 3)  and \@\\
\mbox{}\verb@           event.dblclick == True                      and \@\\
\mbox{}\verb@           event.xdata    != None                      and \@\\
\mbox{}\verb@           event.ydata    != None:@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 1:        @\\
\mbox{}\verb@               newPoint = (event.xdata, event.ydata)@\\
\mbox{}\verb@               run.sites.append( newPoint  )@\\
\mbox{}\verb@               patchSize  = (xlim[1]-xlim[0])/140.0@\\
\mbox{}\verb@   @\\
\mbox{}\verb@               ax.add_patch( mpl.patches.Circle( newPoint,@\\
\mbox{}\verb@                                              radius = patchSize,@\\
\mbox{}\verb@                                              facecolor='blue',@\\
\mbox{}\verb@                                              edgecolor='black'   )  )@\\
\mbox{}\verb@               ax.set_title('Points Inserted: ' + str(len(run.sites)), \@\\
\mbox{}\verb@                             fontdict={'fontsize':40})@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 3:        @\\
\mbox{}\verb@                 inithorseposn = (event.xdata, event.ydata)@\\
\mbox{}\verb@                 run.inithorseposn = inithorseposn  @\\
\mbox{}\verb@                 patchSize  = (xlim[1]-xlim[0])/70.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 # TODO: remove the previous red patches, @\\
\mbox{}\verb@                 # which containg ht eold position@\\
\mbox{}\verb@                 # of the horse and fly. Doing this is @\\
\mbox{}\verb@                 # slightly painful, hence keeping it@\\
\mbox{}\verb@                 # for later@\\
\mbox{}\verb@                 ax.add_patch( mpl.patches.Circle( inithorseposn,@\\
\mbox{}\verb@                                                   radius = patchSize,@\\
\mbox{}\verb@                                                   facecolor= '#D13131', #'red',@\\
\mbox{}\verb@                                                   edgecolor='black'   )  )@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@             # It is inefficient to clear the polygon patches inside the@\\
\mbox{}\verb@             # enterpoints loop as done here.@\\
\mbox{}\verb@             # I have just done this for simplicity: the intended behaviour@\\
\mbox{}\verb@             # at any rate, is@\\
\mbox{}\verb@             # to clear all the polygon patches from the axes object,@\\
\mbox{}\verb@             # once the user starts entering in MORE POINTS TO THE CLOUD@\\
\mbox{}\verb@             # for which the clustering was just computed and rendered.@\\
\mbox{}\verb@             # The moment the user starts entering new points,@\\
\mbox{}\verb@             # the previous polygon patches are garbage collected. @\\
\mbox{}\verb@             clearAxPolygonPatches(ax)@\\
\mbox{}\verb@             applyAxCorrection(ax)@\\
\mbox{}\verb@             fig.canvas.draw()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return _enterPoints@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15a}{, 15a}\NWlink{nuweb15b}{b}\NWlink{nuweb16}{, 16}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Algorithmic Utilities}

\newchunk Given a list of  points $[p_0,p_1,p_2,....p_{n-1}]$. 
    the following function returns, $[p_1-p_0, p_2-p_1,...,p_{n-1}-p_{n-2}]$
    i.e. it converts the list of points into a consecutive list of numpy vectors. 
    Points should be lists or tuples of length 2

\begin{flushleft} \small\label{scrap8}\raggedright\small
\NWtarget{nuweb17a}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {17a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import random@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def vector_chain_from_point_list(pts):@\\
\mbox{}\verb@    """ Given a list of points [p0,p1,p2,....p(n-1)]@\\
\mbox{}\verb@    Make it into a list of numpy vectors @\\
\mbox{}\verb@    [p1-p0, p2-p1,...,p(n-1)-p(n-2)]@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    Points should be lists or tuples of length 2@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    vec_chain = []@\\
\mbox{}\verb@    for pair in zip(pts, pts[1:]):@\\
\mbox{}\verb@        tail= np.array (pair[0])@\\
\mbox{}\verb@        head= np.array (pair[1])@\\
\mbox{}\verb@        vec_chain.append(head-tail)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return vec_chain@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Given a polygonal chain, an important computation is to calculate 
its length. Typically used for computing the length of the horse's and fly's tours. 

\begin{flushleft} \small\label{scrap9}\raggedright\small
\NWtarget{nuweb17b}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {17b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def length_polygonal_chain(pts):@\\
\mbox{}\verb@    """ Given a list of points [p0,p1,p2,....p(n-1)]@\\
\mbox{}\verb@    calculate the length of its segments. @\\
\mbox{}\verb@@\\
\mbox{}\verb@    Points should be lists or tuples of length 2@\\
\mbox{}\verb@@\\
\mbox{}\verb@    If no points or just one point is given in the list of@\\
\mbox{}\verb@    points, then 0 is returned.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    vec_chain = vector_chain_from_point_list(pts)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    acc = 0@\\
\mbox{}\verb@    for vec in vec_chain:@\\
\mbox{}\verb@        acc = acc + np.linalg.norm(vec)@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk The following routine is useful on long lists returned from external solvers. 
Often point-data is given to and returned from these external routines in flattened
form. The following routines are needed to convert such a ``flattened'' list into 
a list of points and vice versa. 

\begin{flushleft} \small\label{scrap10}\raggedright\small
\NWtarget{nuweb18a}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {18a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def pointify_vector (x):@\\
\mbox{}\verb@    """ Convert a vector of even length @\\
\mbox{}\verb@    into a vector of points. i.e.@\\
\mbox{}\verb@    [x0,x1,x2,...x2n] -> [[x0,x1],[x2,x3],,..[x2n-1,x2n]]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    if len(x) % 2 == 0:@\\
\mbox{}\verb@        pts = []@\\
\mbox{}\verb@        for i in range(len(x))[::2]:@\\
\mbox{}\verb@            pts.append( [x[i],x[i+1]] )@\\
\mbox{}\verb@        return pts@\\
\mbox{}\verb@    else :@\\
\mbox{}\verb@        sys.exit('List of items does not have an even length to be able to be pointifyed')@\\
\mbox{}\verb@@\\
\mbox{}\verb@def flatten_list_of_lists(l):@\\
\mbox{}\verb@    """ Flatten vector@\\
\mbox{}\verb@      e.g.  [[0,1],[2,3],[4,5]] -> [0,1,2,3,4,5]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    return [item for sublist in l for item in sublist]@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk Python's default print function prints each list on a single line. For 
debugging purposes,  it helps to print a list with one item per line. 

\begin{flushleft} \small\label{scrap11}\raggedright\small
\NWtarget{nuweb18b}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {18b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def print_list(xs):@\\
\mbox{}\verb@    """ Print each item of a list on new line@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        print x@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk The following routines are self-explanatory and are hence gathered into one chunk. 

\begin{flushleft} \small\label{scrap12}\raggedright\small
\NWtarget{nuweb18c}{} \verb@"../src/lib/utils_algo.py"@\nobreak\ {\footnotesize {18c}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def partial_sums( xs ):@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    List of partial sums@\\
\mbox{}\verb@    [4,2,3] -> [4,6,9]@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    psum = 0@\\
\mbox{}\verb@    acc = []@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        psum = psum+x@\\
\mbox{}\verb@        acc.append( psum )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@@\\
\mbox{}\verb@def are_site_orderings_equal(sites1, sites2):@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    For two given lists of points test if they are @\\
\mbox{}\verb@    equal or not. We do this by checking the Linfinity@\\
\mbox{}\verb@    norm.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    for (x1,y1), (x2,y2) in zip(sites1, sites2): @\\
\mbox{}\verb@        if (x1-x2)**2 + (y1-y2)**2 > 1e-8:@\\
\mbox{}\verb@@\\
\mbox{}\verb@            print Fore.BLUE+ "Site Orderings are not equal"@\\
\mbox{}\verb@            print sites1@\\
\mbox{}\verb@            print sites2@\\
\mbox{}\verb@            print '-------------------------' + Style.RESET_ALL@\\
\mbox{}\verb@            return False@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return True@\\
\mbox{}\verb@        @\\
\mbox{}\verb@    print "\n\n\n\n---------------------"@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def bunch_of_random_points(numpts):@\\
\mbox{}\verb@    cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@    numcenters   = cluster_size@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    import scipy@\\
\mbox{}\verb@    import random@\\
\mbox{}\verb@    centers = scipy.rand(numcenters,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    scale = 4.0@\\
\mbox{}\verb@    points = []@\\
\mbox{}\verb@    for c in centers:@\\
\mbox{}\verb@        cx = c[0]@\\
\mbox{}\verb@        cy = c[1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sq_size      = min(cx,1-cx,cy, 1-cy)@\\
\mbox{}\verb@        cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@        loc_pts_x    = np.random.uniform(low=cx-sq_size/scale, @\\
\mbox{}\verb@                                         high=cx+sq_size/scale, @\\
\mbox{}\verb@                                         size=(cluster_size,))@\\
\mbox{}\verb@        loc_pts_y    = np.random.uniform(low=cy-sq_size/scale, @\\
\mbox{}\verb@                                         high=cy+sq_size/scale, @\\
\mbox{}\verb@                                         size=(cluster_size,))@\\
\mbox{}\verb@@\\
\mbox{}\verb@        points.extend(zip(loc_pts_x, loc_pts_y))@\\
\mbox{}\verb@@\\
\mbox{}\verb@    num_remaining_pts = numpts - cluster_size * numcenters@\\
\mbox{}\verb@@\\
\mbox{}\verb@    remaining_pts = scipy.rand(num_remaining_pts, 2).tolist()@\\
\mbox{}\verb@    points.extend(remaining_pts)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return points@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%---------------------------------------------------------
% Every module is a chapter. Thus we keep the links 
% internal. Any labelling to other modules is done 
% manually. Nuweb provides the .... sectioning 
% commands for this. See Nuweb manual
% http://nuweb.sourceforge.net/nuweb.pdf
% Personally, the important thing for me is not 
% the usage of the identifiers which can be discovered
% with gtags, or just plain simply while reading the book
% from which module (i.e. chapter) the identifier 
% came from. There is no replacement for gtags
% or doxygen like source-code navigation manuals. 
% But then again, usage lists are important within a module. 
% I would like to understand how identifiers are used 
% within modules, rather than how it uses external 
% modules which I can very well also discover using 
% gtags software or possibly doxygen. 
% In this case, my sections are at the problem level 
% because each problem corresponds to a module. 
% Every model is conceptually different, so there is 
% virtually no overlap, between them. Thus we introduce
% sections at the module level and *not* at the algorithm
% An important part of software engineering is engineering
% such loose (actually super-loose) decoupling between 
% software elements, that allows you to maintain the 
% software and pinpoint bugs effectively. 
% I would say, that it helps to document the internal
% wiring of a module rather than what is exported
% I doubt how that is scalable though. If you want to see
% how another module uses an identifier, you should use gtags. 
% and do the navigation. Thus, identifiers will be used for 
% local wiring. I think it is a good approximate solution. 
% Thus, use ... at the modulelevel. 
%----------------------------------------------------------
 
\chapter{Classic Horsefly}
\label{chap:classic-horsefly}

\section{Module Overview}

\newchunk 
All algorithms to solve the classic horsefly problems have been implemented in 
\verb|problem_classic_horsefly.py|. The \verb|run_handler| function acts 
as a kind of main function for this module. It is called from 
\verb|main.py| to process the command-line arguments and run the 
experimental or interactive sections of the code. 

\begin{flushleft} \small\label{scrap13}\raggedright\small
\NWtarget{nuweb21a}{} \verb@"../src/lib/problem_classic_horsefly.py"@\nobreak\ {\footnotesize {21a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Relevant imports for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb21b}{21b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Set up logging information relevant to this module}\nobreak\ {\footnotesize \NWlink{nuweb22a}{22a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@def run_handler():@\\
\mbox{}\verb@    @\hbox{$\langle\,${\itshape Define key-press handler}\nobreak\ {\footnotesize \NWlink{nuweb22b}{22b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@    @\hbox{$\langle\,${\itshape Set up interactive canvas}\nobreak\ {\footnotesize \NWlink{nuweb25a}{25a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Local data-structures for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb25b}{25b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb44a}{44a}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb27}{27}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Plotting routines for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb45}{45}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Animation routines for classic horsefly}\nobreak\ {\footnotesize \NWlink{nuweb47a}{47a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Module Details}

\newchunk 
\begin{flushleft} \small\label{scrap14}\raggedright\small
\NWtarget{nuweb21b}{} $\langle\,${\itshape Relevant imports for classic horsefly}\nobreak\ {\footnotesize {21b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import inspect @\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import logging@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@import utils_algo@\\
\mbox{}\verb@import utils_graphics@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk The logger variable becomes becomes global in scope to this module. This allows
me to write customized \texttt{debug} and \texttt{info} functions that let's me format 
the log messages according to the frame level. I learned this trick from the following 
Stack Overflow post \url{https://stackoverflow.com/a/5500099/505306}. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap15}\raggedright\small
\NWtarget{nuweb22a}{} $\langle\,${\itshape Set up logging information relevant to this module}\nobreak\ {\footnotesize {22a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@logger=logging.getLogger(__name__)@\\
\mbox{}\verb@logging.basicConfig(level=logging.INFO)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def debug(msg):@\\
\mbox{}\verb@    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(@\\
\mbox{}\verb@        inspect.currentframe())[1]@\\
\mbox{}\verb@    line=lines[0]@\\
\mbox{}\verb@    indentation_level=line.find(line.lstrip())@\\
\mbox{}\verb@    logger.debug('{i} [{m}]'.format(@\\
\mbox{}\verb@        i='.'*indentation_level, m=msg))@\\
\mbox{}\verb@@\\
\mbox{}\verb@def info(msg):@\\
\mbox{}\verb@    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(@\\
\mbox{}\verb@        inspect.currentframe())[1]@\\
\mbox{}\verb@    line=lines[0]@\\
\mbox{}\verb@    indentation_level=line.find(line.lstrip())@\\
\mbox{}\verb@    logger.info('{i} [{m}]'.format(@\\
\mbox{}\verb@        i='.'*indentation_level, m=msg))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@logger@\nobreak\ \NWlink{nuweb33b}{33b}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk The key-press handler function detects the keys pressed by the user when the canvas
is in active focus. This function allows you to set some of the input parameters like 
speed ratio $\varphi$, or selecting an algorithm interactively at the command-line, 
generating a bunch of uniform or non-uniformly distributed points on the canvas, 
or just plain clearing the canvas for inserting a fresh input set of points. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap16}\raggedright\small
\NWtarget{nuweb22b}{} $\langle\,${\itshape Define key-press handler}\nobreak\ {\footnotesize {22b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@# The key-stack argument is mutable! I am using this hack to my advantage.@\\
\mbox{}\verb@def wrapperkeyPressHandler(fig,ax, run): @\\
\mbox{}\verb@       def _keyPressHandler(event):@\\
\mbox{}\verb@           if event.key in ['i', 'I']:  @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Start entering input from the command-line}\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           elif event.key in ['n', 'N', 'u', 'U']: @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Generate a bunch of uniform or non-uniform random points on the canvas}\nobreak\ {\footnotesize \NWlink{nuweb24a}{24a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           elif event.key in ['c', 'C']: @\\
\mbox{}\verb@                @\hbox{$\langle\,${\itshape Clear canvas and states of all objects}\nobreak\ {\footnotesize \NWlink{nuweb24b}{24b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@       return _keyPressHandler@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@wrapperkeyPressHandler@\nobreak\ \NWlink{nuweb25a}{25a}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap17}\raggedright\small
\NWtarget{nuweb22c}{} $\langle\,${\itshape Start entering input from the command-line}\nobreak\ {\footnotesize {22c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@phi_str = raw_input(Fore.YELLOW + \@\\
\mbox{}\verb@          "Enter speed of fly (should be >1): " +\@\\
\mbox{}\verb@           Style.RESET_ALL)@\\
\mbox{}\verb@phi = float(phi_str)@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_str = raw_input(Fore.YELLOW + \@\\
\mbox{}\verb@          "Enter algorithm to be used to compute the tour:\n Options are:\n" +\@\\
\mbox{}\verb@        "  (e)   Exact \n"                                   +\@\\
\mbox{}\verb@        "  (t)   TSP   \n"                                   +\@\\
\mbox{}\verb@        "  (tl)  TSP   (using approximate L1 ordering)\n"    +\@\\
\mbox{}\verb@        "  (k)   k2-center   \n"                             +\@\\
\mbox{}\verb@        "  (kl)  k2-center (using approximate L1 ordering)\n"  +\@\\
\mbox{}\verb@        "  (g)   Greedy\n"                                   +\@\\
\mbox{}\verb@        "  (gl)  Greedy (using approximate L1 ordering])\n"  +\@\\
\mbox{}\verb@        "  (ginc) Greedy Incremental  "  +\@\\
\mbox{}\verb@        Style.RESET_ALL)@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_str = algo_str.lstrip()@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Incase there are patches present from the previous clustering, just clear them@\\
\mbox{}\verb@utils_graphics.clearAxPolygonPatches(ax)@\\
\mbox{}\verb@@\\
\mbox{}\verb@if   algo_str == 'e':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_dumb,@\\
\mbox{}\verb@                          phi )@\\
\mbox{}\verb@elif algo_str == 'k': @\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_kmeans,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          k=2,@\\
\mbox{}\verb@                          post_optimizer=algo_exact_given_specific_ordering)@\\
\mbox{}\verb@      print " "@\\
\mbox{}\verb@      print Fore.GREEN, answer['tour_points'], Style.RESET_ALL@\\
\mbox{}\verb@elif algo_str == 'kl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_kmeans,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          k=2,@\\
\mbox{}\verb@                          post_optimizer=algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 't':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_tsp_ordering,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer=algo_exact_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'tl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_tsp_ordering,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'g':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_greedy,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_exact_given_specific_ordering)@\\
\mbox{}\verb@elif algo_str == 'gl':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_greedy,@\\
\mbox{}\verb@                          phi,@\\
\mbox{}\verb@                          post_optimizer= algo_approximate_L1_given_specific_ordering)@\\
\mbox{}\verb@                          @\\
\mbox{}\verb@elif algo_str == 'ginc':@\\
\mbox{}\verb@      horseflytour = \@\\
\mbox{}\verb@             run.getTour( algo_greedy_incremental_insertion,@\\
\mbox{}\verb@                          phi )@\\
\mbox{}\verb@@\\
\mbox{}\verb@else:@\\
\mbox{}\verb@      print "Unknown option. No horsefly for you! ;-D "@\\
\mbox{}\verb@      sys.exit()@\\
\mbox{}\verb@@\\
\mbox{}\verb@#print horseflytour['tour_points']@\\
\mbox{}\verb@plotTour(ax,horseflytour, run.inithorseposn, phi, algo_str)@\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22b}{22b}.
\item \NWtxtIdentsUsed\nobreak\  \verb@algo_exact_given_specific_ordering@\nobreak\ \NWlink{nuweb29}{29}, \verb@algo_greedy_incremental_insertion,@\nobreak\ \NWlink{nuweb33a}{33a}, \verb@plotTour@\nobreak\ \NWlink{nuweb45}{45}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk This chunk generates points uniformly or non-uniformly distributed in the 
unit square $[0,1]^2$ in the Matplotlib canvas. I will document the schemes used for 
generating the non-uniformly distributed points later. These schemes are important to test the effectiveness of 
the horsefly algorithms. Uniform point clouds do no highlight the weaknesses of 
sequencing algorithms as David Johnson implies in his article on how to write 
experimental algorithm papers when he talks about algorithms for the TSP. 

\begin{flushleft} \small\label{scrap18}\raggedright\small
\NWtarget{nuweb24a}{} $\langle\,${\itshape Generate a bunch of uniform or non-uniform random points on the canvas}\nobreak\ {\footnotesize {24a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@numpts = int(raw_input("\n" + Fore.YELLOW+\@\\
\mbox{}\verb@                       "How many points should I generate?: "+\@\\
\mbox{}\verb@                       Style.RESET_ALL)) @\\
\mbox{}\verb@run.clearAllStates()@\\
\mbox{}\verb@ax.cla()@\\
\mbox{}\verb@               @\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@                @\\
\mbox{}\verb@fig.texts = []@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@import scipy@\\
\mbox{}\verb@if event.key in ['n', 'N']: # Non-uniform random points@\\
\mbox{}\verb@        run.sites = utils_algo.bunch_of_random_points(numpts)@\\
\mbox{}\verb@else : # Uniform random points@\\
\mbox{}\verb@        run.sites = scipy.rand(numpts,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@patchSize  = (utils_graphics.xlim[1]-utils_graphics.xlim[0])/140.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@for site in run.sites:      @\\
\mbox{}\verb@    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \@\\
\mbox{}\verb@                 facecolor='blue',edgecolor='black' ))@\\
\mbox{}\verb@@\\
\mbox{}\verb@ax.set_title('Points : ' + str(len(run.sites)), fontdict={'fontsize':40})@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22b}{22b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 

\begin{flushleft} \small\label{scrap19}\raggedright\small
\NWtarget{nuweb24b}{} $\langle\,${\itshape Clear canvas and states of all objects}\nobreak\ {\footnotesize {24b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@run.clearAllStates()@\\
\mbox{}\verb@ax.cla()@\\
\mbox{}\verb@              @\\
\mbox{}\verb@utils_graphics.applyAxCorrection(ax)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@fig.texts = []@\\
\mbox{}\verb@fig.canvas.draw()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22b}{22b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap20}\raggedright\small
\NWtarget{nuweb25a}{} $\langle\,${\itshape Set up interactive canvas}\nobreak\ {\footnotesize {25a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@fig, ax =  plt.subplots()@\\
\mbox{}\verb@run = HorseFlyInput()@\\
\mbox{}\verb@#print run@\\
\mbox{}\verb@    @\\
\mbox{}\verb@ax.set_xlim([utils_graphics.xlim[0], utils_graphics.xlim[1]])@\\
\mbox{}\verb@ax.set_ylim([utils_graphics.ylim[0], utils_graphics.ylim[1]])@\\
\mbox{}\verb@ax.set_aspect(1.0)@\\
\mbox{}\verb@ax.set_xticks([])@\\
\mbox{}\verb@ax.set_yticks([])@\\
\mbox{}\verb@      @\\
\mbox{}\verb@mouseClick   = utils_graphics.wrapperEnterRunPoints (fig,ax, run)@\\
\mbox{}\verb@fig.canvas.mpl_connect('button_press_event' , mouseClick )@\\
\mbox{}\verb@      @\\
\mbox{}\verb@keyPress     = wrapperkeyPressHandler(fig,ax, run)@\\
\mbox{}\verb@fig.canvas.mpl_connect('key_press_event', keyPress   )@\\
\mbox{}\verb@plt.show()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@HorseFlyInput@\nobreak\ \NWlink{nuweb25b}{25b}, \verb@wrapperkeyPressHandler@\nobreak\ \NWlink{nuweb22b}{22b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Local Data Structures}

\newchunk This class manages the input and the output of the result of 
calling various horsefly algorithms. 

\begin{flushleft} \small\label{scrap21}\raggedright\small
\NWtarget{nuweb25b}{} $\langle\,${\itshape Local data-structures for classic horsefly}\nobreak\ {\footnotesize {25b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@class HorseFlyInput:@\\
\mbox{}\verb@      def __init__(self, sites=[], inithorseposn=()):@\\
\mbox{}\verb@           self.sites         = sites@\\
\mbox{}\verb@           self.inithorseposn = inithorseposn@\\
\mbox{}\verb@@\\
\mbox{}\verb@           @\\
\mbox{}\verb@      def clearAllStates (self):@\\
\mbox{}\verb@          """ Set the sites to an empty list and initial horse position @\\
\mbox{}\verb@          to the empty tuple.@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@          self.sites = []@\\
\mbox{}\verb@          self.inithorseposn = ()@\\
\mbox{}\verb@@\\
\mbox{}\verb@          @\\
\mbox{}\verb@      def getTour(self, algo, speedratio, k=None, post_optimizer=None):@\\
\mbox{}\verb@          """ This method runs an appropriate algorithm for calculating@\\
\mbox{}\verb@          a horsefly tour. The list of possible algorithms are @\\
\mbox{}\verb@          inside this module prefixed with 'algo_'@\\
\mbox{}\verb@          @\\
\mbox{}\verb@          The output is a dictionary of size 2, containing two lists,@\\
\mbox{}\verb@          - Contains the vertices of the polygonal @\\
\mbox{}\verb@            path taken by the horse@\\
\mbox{}\verb@          - The list of sites in the order @\\
\mbox{}\verb@            in which they are serviced by the tour, i.e. the order @\\
\mbox{}\verb@            in which the sites are serviced by the fly.@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if k==None and post_optimizer==None:@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio)@\\
\mbox{}\verb@          elif k == None:@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio, post_optimizer)@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@                #print Fore.RED, self.sites, Style.RESET_ALL@\\
\mbox{}\verb@                return algo(self.sites, self.inithorseposn, speedratio, k, post_optimizer)@\\
\mbox{}\verb@          @\\
\mbox{}\verb@      def __repr__(self):@\\
\mbox{}\verb@          """ Printed Representation of the Input for HorseFly@\\
\mbox{}\verb@          """@\\
\mbox{}\verb@          if self.sites != []:@\\
\mbox{}\verb@              tmp = ''@\\
\mbox{}\verb@              for site in self.sites:@\\
\mbox{}\verb@                  tmp = tmp + '\n' + str(site)@\\
\mbox{}\verb@              sites = "The list of sites to be serviced are " + tmp    @\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              sites = "The list of sites is empty"@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if self.inithorseposn != ():@\\
\mbox{}\verb@              inithorseposn = "\nThe initial position of the horse is " + \@\\
\mbox{}\verb@                               str(self.inithorseposn)@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              inithorseposn = "\nThe initial position of the horse has not been specified"@\\
\mbox{}\verb@              @\\
\mbox{}\verb@          return sites + inithorseposn@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@HorseFlyInput@\nobreak\ \NWlink{nuweb25a}{25a}.\item \NWtxtIdentsUsed\nobreak\  \verb@self.inithorseposn,@\nobreak\ \NWlink{nuweb41a}{41a}, \verb@self.sites,@\nobreak\ \NWlink{nuweb41a}{41a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
Now that all the boring boiler-plate and handler codes have been 
written, its finally time for algorithmic ideas and implementations! 
Every algorithm is given an algorithmic overview followed by the 
detailed steps woven together with the source code. 

Any local utility functions, needed for algorithmic or graphing purposes 
are collected at the end of this chapter. 

\newpage

\section{Algorithm: Dumb Brute force}

\subsection{Algorithmic Overview}

\subsection{Algorithmic Details}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap22}\raggedright\small
\NWtarget{nuweb27}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {27}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def algo_dumb(sites, horseflyinit, phi):@\\
\mbox{}\verb@    """ For each of the n factorial ordering of sites@\\
\mbox{}\verb@    find the ordering which gives the smallest horsefly @\\
\mbox{}\verb@    tour length@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    tour_length_fn = tour_length(horseflyinit)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    best_tour = algo_exact_given_specific_ordering(sites, horseflyinit, phi)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    i = 0@\\
\mbox{}\verb@    for sites_perm in list(itertools.permutations(sites)):@\\
\mbox{}\verb@        print "Testing a new permutation ", i, " of the sites"; i = i + 1@\\
\mbox{}\verb@          @\\
\mbox{}\verb@        #tour_for_current_perm = algo_exact_given_specific_ordering (sites_perm, \@\\
\mbox{}\verb@        #                                                             horseflyinit, phi) @\\
\mbox{}\verb@        tour_for_current_perm = algo_exact_given_specific_ordering (sites_perm, \@\\
\mbox{}\verb@                                                                    horseflyinit, phi) @\\
\mbox{}\verb@        if tour_length_fn(utils_algo.flatten_list_of_lists(tour_for_current_perm ['tour_points']) ) \@\\
\mbox{}\verb@         < tour_length_fn(utils_algo.flatten_list_of_lists(            best_tour ['tour_points']) ):@\\
\mbox{}\verb@                best_tour = tour_for_current_perm@\\
\mbox{}\verb@                @\\
\mbox{}\verb@                print Fore.RED + "Found better tour!" + Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    #print Fore.RED + "\nHorse Waiting times are ",\ @\\
\mbox{}\verb@    #       best_tour['horse_waiting_times'] , \@\\
\mbox{}\verb@    #       Style.RESET_ALL@\\
\mbox{}\verb@    return best_tour@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb27}{27}\NWlink{nuweb28}{, 28}\NWlink{nuweb29}{, 29}\NWlink{nuweb33a}{, 33a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@algo_exact_given_specific_ordering@\nobreak\ \NWlink{nuweb29}{29}, \verb@tour_length@\nobreak\ \NWlink{nuweb44a}{44a}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Algorithm: Greedy---Nearest Neighbor}  
\label{sec:greedy-nn}
\subsection{Algorithmic Overview}
\newchunk Before proceeding we give a special case of the 
          classical horseflies problem, which we term 
         ``collinear-horsefly''. Here the objective function
         is again to minimize the tour-length of the drone
         with the additional restriction that the truck must
     always be moving in a straight line towards the site on the 
line-segment joining itself and the site, while the drone is also 
restricted to travelling along the same line segment. 

\begin{figure}[H]
\centering
    \includegraphics[width=7cm]{../webs/docs/collinear_horseflies.eps}
    \caption{The Collinear Horsefly Problem}
    \label{fig:collinear-horseflies}
\end{figure}

We can show that an optimal (unrestricted) horsfly solution can be converted
to a collinear-horsefly solution at a constant factor increase in the makespan. 

\subsection{Algorithmic Details}
\begin{flushleft} \small\label{scrap23}\raggedright\small
\NWtarget{nuweb28}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {28}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@def algo_greedy(sites, inithorseposn, phi, post_optimizer):@\\
\mbox{}\verb@      """@\\
\mbox{}\verb@      This implements the greedy algorithm for the canonical greedy@\\
\mbox{}\verb@      algorithm for collinear horsefly, and then uses the ordering @\\
\mbox{}\verb@      obtained to get the exact tour for that given ordering.@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      Many variations on this are possible. However, this algorithm@\\
\mbox{}\verb@      is simple and may be more amenable to theoretical analysis. @\\
\mbox{}\verb@      @\\
\mbox{}\verb@      We will need an inequality for collapsing chains however. @\\
\mbox{}\verb@      """@\\
\mbox{}\verb@      def next_rendezvous_point_for_horse_and_fly(horseposn, site):@\\
\mbox{}\verb@            """@\\
\mbox{}\verb@            Just use the exact solution when there is a single site. @\\
\mbox{}\verb@            No need to use the collinear horse formula which you can @\\
\mbox{}\verb@            explicitly derive. That formula is  an important super-special @\\
\mbox{}\verb@            case however to benchmark quality of solution. @\\
\mbox{}\verb@            """@\\
\mbox{}\verb@@\\
\mbox{}\verb@            horseflytour = algo_exact_given_specific_ordering([site], horseposn, phi)@\\
\mbox{}\verb@            return horseflytour['tour_points'][-1]@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      # Begin the recursion process where for a given initial@\\
\mbox{}\verb@      # position of horse and fly and a given collection of sites@\\
\mbox{}\verb@      # you find the nearst neighbor proceed according to segment@\\
\mbox{}\verb@      # horsefly formula for just and one site, and for the new@\\
\mbox{}\verb@      # position repeat the process for the remaining list of sites. @\\
\mbox{}\verb@      # The greedy approach can be extended to by finding the k@\\
\mbox{}\verb@      # nearest neighbors, constructing the exact horsefly tour@\\
\mbox{}\verb@      # there, at the exit point, you repeat by taking k nearest@\\
\mbox{}\verb@      # neighbors and so on. @\\
\mbox{}\verb@      def greedy(current_horse_posn, remaining_sites):@\\
\mbox{}\verb@            if len(remaining_sites) == 1:@\\
\mbox{}\verb@                  return remaining_sites@\\
\mbox{}\verb@            else:@\\
\mbox{}\verb@                  # For reference see this link on how nn queries are performed. @\\
\mbox{}\verb@                  # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html@\\
\mbox{}\verb@                  # Warning this is inefficient!!! I am rebuilding the @\\
\mbox{}\verb@                  # kd-tree at each step. Right now, I am only doing @\\
\mbox{}\verb@                  # this for convenience.@\\
\mbox{}\verb@                  from scipy import spatial@\\
\mbox{}\verb@                  tree = spatial.KDTree(remaining_sites)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  # The next site to get serviced by the drone and horse@\\
\mbox{}\verb@                  # is the one which is closest to the current position of the@\\
\mbox{}\verb@                  # horse. @\\
\mbox{}\verb@                  pts           = np.array([current_horse_posn])@\\
\mbox{}\verb@                  query_result  = tree.query(pts)@\\
\mbox{}\verb@                  next_site_idx = query_result[1][0]@\\
\mbox{}\verb@                  next_site     = remaining_sites[next_site_idx]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  next_horse_posn = \@\\
\mbox{}\verb@                        next_rendezvous_point_for_horse_and_fly(current_horse_posn, next_site)@\\
\mbox{}\verb@                  #print remaining_sites@\\
\mbox{}\verb@                  remaining_sites.pop(next_site_idx) # the pop method modifies the list in place. @\\
\mbox{}\verb@                  @\\
\mbox{}\verb@                  return [ next_site ] + greedy (current_horse_posn = next_horse_posn, \@\\
\mbox{}\verb@                                                 remaining_sites    = remaining_sites)@\\
\mbox{}\verb@@\\
\mbox{}\verb@      sites1 = sites[:]@\\
\mbox{}\verb@      sites_ordered_by_greedy = greedy(inithorseposn, remaining_sites=sites1)@\\
\mbox{}\verb@@\\
\mbox{}\verb@      # Use exact solver for the post optimizer step@\\
\mbox{}\verb@      answer = post_optimizer(sites_ordered_by_greedy, inithorseposn, phi)@\\
\mbox{}\verb@      return answer@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb27}{27}\NWlink{nuweb28}{, 28}\NWlink{nuweb29}{, 29}\NWlink{nuweb33a}{, 33a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@algo_exact_given_specific_ordering@\nobreak\ \NWlink{nuweb29}{29}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\newchunk 

\begin{flushleft} \small\label{scrap24}\raggedright\small
\NWtarget{nuweb29}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {29}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@# ALGORITHMS FOR SINGLE HORSE SINGLE FLY SERVICING THE SITES IN THE GIVEN ORDER@\\
\mbox{}\verb@def algo_exact_given_specific_ordering (sites, horseflyinit, phi):@\\
\mbox{}\verb@    """ Use the *given* ordering of sites to compute a good tour @\\
\mbox{}\verb@    for the horse.@\\
\mbox{}\verb@    """@\\
\mbox{}\verb@    def ith_leg_constraint(i, horseflyinit, phi, sites):@\\
\mbox{}\verb@        """ For the ith segment of the horsefly tour@\\
\mbox{}\verb@        this function returns a constraint function which @\\
\mbox{}\verb@        models the fact that the time taken by the fly @\\
\mbox{}\verb@        is equal to the time taken by the horse along @\\
\mbox{}\verb@        that particular segment.@\\
\mbox{}\verb@        """@\\
\mbox{}\verb@        if i == 0 :@\\
\mbox{}\verb@            def _constraint_function(x):@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                #print "Constraint  ", i@\\
\mbox{}\verb@                start = np.array (horseflyinit)@\\
\mbox{}\verb@                site  = np.array (sites[0])@\\
\mbox{}\verb@                stop  = np.array ([x[0],x[1]])@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                horsetime = np.linalg.norm( stop - start )@\\
\mbox{}\verb@            @\\
\mbox{}\verb@                flytime_to_site   = 1/phi * np.linalg.norm( site - start )@\\
\mbox{}\verb@                flytime_from_site = 1/phi * np.linalg.norm( stop - site  )@\\
\mbox{}\verb@                flytime           = flytime_to_site + flytime_from_site@\\
\mbox{}\verb@                return horsetime-flytime@\\
\mbox{}\verb@@\\
\mbox{}\verb@            return _constraint_function@\\
\mbox{}\verb@        else :@\\
\mbox{}\verb@          @\\
\mbox{}\verb@            def _constraint_function(x):@\\
\mbox{}\verb@@\\
\mbox{}\verb@               #print "Constraint  ", i@\\
\mbox{}\verb@               start = np.array (  [x[2*i-2], x[2*i-1]]  ) @\\
\mbox{}\verb@               site  = np.array (  sites[i])@\\
\mbox{}\verb@               stop  = np.array (  [x[2*i]  , x[2*i+1]]  )@\\
\mbox{}\verb@            @\\
\mbox{}\verb@               horsetime = np.linalg.norm( stop - start )@\\
\mbox{}\verb@           @\\
\mbox{}\verb@               flytime_to_site   = 1/phi * np.linalg.norm( site - start )@\\
\mbox{}\verb@               flytime_from_site = 1/phi * np.linalg.norm( stop - site  )@\\
\mbox{}\verb@               flytime           = flytime_to_site + flytime_from_site@\\
\mbox{}\verb@               return horsetime-flytime@\\
\mbox{}\verb@@\\
\mbox{}\verb@            return _constraint_function@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    def generate_constraints(horseflyinit, phi, sites):@\\
\mbox{}\verb@        """ Given input data, of the problem generate the @\\
\mbox{}\verb@        constraint list for each leg of the tour. The number@\\
\mbox{}\verb@        of legs is equal to the number of sites for the case @\\
\mbox{}\verb@        of single horse, single drone@\\
\mbox{}\verb@        """@\\
\mbox{}\verb@        cons = []@\\
\mbox{}\verb@        for i in range(len(sites)):@\\
\mbox{}\verb@            cons.append( { 'type':'eq',@\\
\mbox{}\verb@                            'fun': ith_leg_constraint(i,horseflyinit,phi, sites) } )@\\
\mbox{}\verb@        return cons@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    cons = generate_constraints(horseflyinit, phi, sites)@\\
\mbox{}\verb@    # Since the horsely tour lies inside the square,@\\
\mbox{}\verb@    # the bounds for each coordinate is 0 and 1@\\
\mbox{}\verb@    #x0 = np.empty(2*len(sites))@\\
\mbox{}\verb@    #x0.fill(0.5) # choice of filling vector with 0.5 is arbitrary@\\
\mbox{}\verb@@\\
\mbox{}\verb@    x0 = utils_algo.flatten_list_of_lists(sites) # the initial choice is just the sites@\\
\mbox{}\verb@    assert(len(x0) == 2*len(sites))@\\
\mbox{}\verb@    x0 = np.array(x0)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    sol = minimize(tour_length(horseflyinit), x0, method= 'SLSQP', \@\\
\mbox{}\verb@                               constraints=cons, options={'maxiter':500})@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    tour_points = utils_algo.pointify_vector(sol.x)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # return the waiting times for the horse@\\
\mbox{}\verb@    numsites            = len(sites)@\\
\mbox{}\verb@    alpha               = horseflyinit[0]@\\
\mbox{}\verb@    beta                = horseflyinit[1]@\\
\mbox{}\verb@    s                   = utils_algo.flatten_list_of_lists(sites)@\\
\mbox{}\verb@    horse_waiting_times = np.zeros(numsites)@\\
\mbox{}\verb@    ps                  = sol.x@\\
\mbox{}\verb@    for i in range(numsites):@\\
\mbox{}\verb@        if i == 0 :@\\
\mbox{}\verb@            horse_time         = np.sqrt((ps[0]-alpha)**2 + (ps[1]-beta)**2)@\\
\mbox{}\verb@            fly_time_to_site   = 1.0/phi * np.sqrt((s[0]-alpha)**2 + (s[1]-beta)**2 )@\\
\mbox{}\verb@            fly_time_from_site = 1.0/phi * np.sqrt((s[0]-ps[1])**2 + (s[1]-ps[1])**2)@\\
\mbox{}\verb@        else:@\\
\mbox{}\verb@            horse_time         = np.sqrt((ps[2*i]-ps[2*i-2])**2 + (ps[2*i+1]-ps[2*i-1])**2)@\\
\mbox{}\verb@            fly_time_to_site   = 1.0/phi * np.sqrt(( (s[2*i]-ps[2*i-2])**2 + (s[2*i+1]-ps[2*i-1])**2 )) @\\
\mbox{}\verb@            fly_time_from_site = 1.0/phi * np.sqrt(( (s[2*i]-ps[2*i])**2   + (s[2*i+1]-ps[2*i+1])**2 )) @\\
\mbox{}\verb@@\\
\mbox{}\verb@        horse_waiting_times[i] = horse_time - (fly_time_to_site + fly_time_from_site)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return {'tour_points'                : tour_points,@\\
\mbox{}\verb@            'horse_waiting_times'        : horse_waiting_times, @\\
\mbox{}\verb@            'site_ordering'              : sites,@\\
\mbox{}\verb@            'tour_length_with_waiting_time_included': \@\\
\mbox{}\verb@                                       tour_length_with_waiting_time_included(\@\\
\mbox{}\verb@                                                    tour_points, \@\\
\mbox{}\verb@                                                    horse_waiting_times, @\\
\mbox{}\verb@                                                    horseflyinit)}@\\
\mbox{}\verb@   @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb27}{27}\NWlink{nuweb28}{, 28}\NWlink{nuweb29}{, 29}\NWlink{nuweb33a}{, 33a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@algo_exact_given_specific_ordering@\nobreak\ \NWlink{nuweb22c}{22c}\NWlink{nuweb27}{, 27}\NWlink{nuweb28}{, 28}.\item \NWtxtIdentsUsed\nobreak\  \verb@tour_length@\nobreak\ \NWlink{nuweb44a}{44a}, \verb@tour_length_with_waiting_time_included@\nobreak\ \NWlink{nuweb44b}{44b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Algorithm: Greedy---Incremental Insertion}
\subsection*{Algorithmic Overview}
\newchunk The greedy nearest neighbor heuristic described in \autoref{sec:greedy-nn} gives an $O(\log n)$ 
          approximation for $n$ sites in the plane. However, there exists an alternative greedy incremental 
          insertion algorithm for the TSP that yields a 2-approximation. Similar to the greedy-nn algorithm 
          we can generalize the greedy-incremental approach to the collinear-horseflies setting 
          (cf: \autoref{fig:collinear-horseflies}). 

\newchunk In this approach, we maintain a list of visited sites $V$ (along with the order of visitation 
          $\mathcal{O}$) and the unvisited sites $U$. For the given collinear-horsefly tour serving $V$ 
          pick a site $s$ from $U$ along with a position in $\mathcal{O}$ (calling the resulting ordering  
          $\mathcal{O^{'}}$  ) that minimizes the cost of the horsefly tour serving the sites $V \cup \{s\}$ 
          in the order $\mathcal{O^{'}}$. 

% \begin{figure}[H]
% \centering
% \includegraphics[width=8cm]{../webs/docs/incremental_insertion_frames.eps}
% \end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{cc}
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00000.png}&
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00001.png}\\
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00002.png}&
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00003.png}\\
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00004.png}&
\includegraphics[width=8cm]{../webs/docs/algo-greedy-incremental-insertion---Day-2018-12-24_ClockTime-19:31:02/algo_state_00005.png}\\
\end{tabular}
\caption{Greedy incremental insertion for collinear horseflies. $\varphi=3.0$. Notice that 
the ordering of the visited sites keep changing based on where we decide to insert an 
unvisited site.}
\label{fig:greedy-incremental-example}
\end{figure}


\autoref{fig:greedy-incremental-example} depicts the incremental insertion process for 
the case of 4 sites and $\varphi=3$. Notice that the ordering of the visited sites keep 
changing based on where we decide to insert an unvisited site. 

The implementation of this algorithm for collinear-horseflies raises several interesting non-trivial 
data-structural questions in their own right: how to quickly find the site from $U$ to 
insert into $V$, and keep track the changing length of the horsefly tour. Note that inserting a site 
causes the length of the tour of the truck to change, for all the sites after $s$. 
 
\subsection*{Algorithmic Details}
\newchunk The implementation of the algorithm is ``parametrized'' over various strategies for insertion. 
i.e. we treat each insertion policy as a black-box argument to the function.
 
Efficient policies for detecting the exact or approximate point for cheapest insertion will be 
described in \autoref{subsec:insertion-policies}.  We also implement a ``naive'' policy as a way 
benchmark the quality and speed of implementation of future insertion policies. 

\begin{flushleft} \small\label{scrap25}\raggedright\small
\NWtarget{nuweb33a}{} $\langle\,${\itshape Algorithms for classic horsefly}\nobreak\ {\footnotesize {33a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Define auxiliary helper functions}\nobreak\ {\footnotesize \NWlink{nuweb39c}{39c}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape Define various insertion policy classes}\nobreak\ {\footnotesize \NWlink{nuweb41a}{41a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@def algo_greedy_incremental_insertion(sites, inithorseposn, phi,@\\
\mbox{}\verb@                                      insertion_policy_name       = "naive",@\\
\mbox{}\verb@                                      write_algo_states_to_disk_p = True   ,@\\
\mbox{}\verb@                                      animate_schedule_p          = True   , @\\
\mbox{}\verb@                                      post_optimizer              = None):@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Set log, algo-state and input-output files config}\nobreak\ {\footnotesize \NWlink{nuweb33b}{33b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Set insertion policy class for current run}\nobreak\ {\footnotesize \NWlink{nuweb34a}{34a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@      while insertion_policy.unvisited_sites_idxs: @\\
\mbox{}\verb@         @\hbox{$\langle\,${\itshape Use insertion policy to find the cheapest site to insert into current tour}\nobreak\ {\footnotesize \NWlink{nuweb34b}{34b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@         @\hbox{$\langle\,${\itshape Write algorithm's current state to file}\nobreak\ {\footnotesize \NWlink{nuweb35a}{35a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Write input and output to file}\nobreak\ {\footnotesize \NWlink{nuweb38a}{38a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Make an animation of the schedule, if \verb|animate_schedule_p == True|}\nobreak\ {\footnotesize \NWlink{nuweb39a}{39a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      sys.exit()@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Make an animation of algorithm states, if \verb|write_algo_states_to_disk_p == True|}\nobreak\ {\footnotesize \NWlink{nuweb38b}{38b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Return horsefly tour, along with additional information}\nobreak\ {\footnotesize \NWlink{nuweb39b}{39b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb27}{27}\NWlink{nuweb28}{, 28}\NWlink{nuweb29}{, 29}\NWlink{nuweb33a}{, 33a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@algo_greedy_incremental_insertion,@\nobreak\ \NWlink{nuweb22c}{22c}, \verb@write_algo_states_to_disk_p@\nobreak\ \NWlink{nuweb35a}{35a}\NWlink{nuweb35b}{b}\NWlink{nuweb38b}{, 38b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk Note that for each run of the algorithm, we create a dedicated directory and 
use a corresponding log file  in that directory. It will typically containe detailed 
information on the progress of the algorithm and the steps executed. 

For algorithm analysis, and verification of correctness,on the other hand, we will 
typically  be interested in the states of the data-structures at the end of 
the while loop; each such state will be written out as a YAML file. Such files can 
be useful for animating the progress of the algorithm. 

Finally, just before returning the answer, we write the input and output 
to a separate YAML file. All in all, there are three ``types'' of output files
within each directory that corresponds to an algorithm's run: 
\underline{a log file}, \underline{algorithm states files}, and finally 
an \underline{input-output file}. 

\begin{flushleft} \small\label{scrap26}\raggedright\small
\NWtarget{nuweb33b}{} $\langle\,${\itshape Set log, algo-state and input-output files config}\nobreak\ {\footnotesize {33b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@  @\\
\mbox{}\verb@import sys, logging, datetime, os, errno@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_name     = 'algo-greedy-incremental-insertion'@\\
\mbox{}\verb@time_stamp    = datetime.datetime.now().strftime('Day-%Y-%m-%d_ClockTime-%H:%M:%S')@\\
\mbox{}\verb@dir_name      = algo_name + '---' + time_stamp@\\
\mbox{}\verb@log_file_name = dir_name + '/' + 'run.log'@\\
\mbox{}\verb@io_file_name  = 'input_and_output.yml'@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Create directory for writing data-files and logs to for @\\
\mbox{}\verb@# current run of this algorithm@\\
\mbox{}\verb@try:@\\
\mbox{}\verb@    os.makedirs(dir_name)@\\
\mbox{}\verb@except OSError as e:@\\
\mbox{}\verb@    if e.errno != errno.EEXIST:@\\
\mbox{}\verb@        raise@\\
\mbox{}\verb@@\\
\mbox{}\verb@logging.basicConfig( filename = log_file_name,@\\
\mbox{}\verb@                     level    = logging.DEBUG,@\\
\mbox{}\verb@                     format   = '%(asctime)s: %(levelname)s: %(message)s',@\\
\mbox{}\verb@                     filemode = 'w' )@\\
\mbox{}\verb@#logger = logging.getLogger()@\\
\mbox{}\verb@info("Started running greedy_incremental_insertion for classic horsefly")@\\
\mbox{}\verb@@\\
\mbox{}\verb@algo_state_counter = 0 @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@io_file_name,@\nobreak\ \NWlink{nuweb38a}{38a}, \verb@logger@\nobreak\ \NWlink{nuweb22a}{22a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk This fragment merely sets the variable \verb|insertion_policy| to 
the appropriate function. This will later help us in studying the speed of 
the algorithm and quality of the solution for various insertion policies 
during the experimental analysis. 

\begin{flushleft} \small\label{scrap27}\raggedright\small
\NWtarget{nuweb34a}{} $\langle\,${\itshape Set insertion policy class for current run}\nobreak\ {\footnotesize {34a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@if insertion_policy_name == "naive":@\\
\mbox{}\verb@     insertion_policy = PolicyBestInsertionNaive(sites, inithorseposn, phi)@\\
\mbox{}\verb@else: @\\
\mbox{}\verb@     print insertion_policy_name@\\
\mbox{}\verb@     sys.exit("Unknown insertion policy: ")@\\
\mbox{}\verb@debug("Finished setting insertion policy: " + insertion_policy_name)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk Note that while defining the body of the algorithm, we treat the insertion policy 
(whose name has already been passed as an string argument) as a kind of black-box, since all 
policy classes have the same interface. The detailed implementation for the various 
insertion policies are given later. 

\begin{flushleft} \small\label{scrap28}\raggedright\small
\NWtarget{nuweb34b}{} $\langle\,${\itshape Use insertion policy to find the cheapest site to insert into current tour}\nobreak\ {\footnotesize {34b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@insertion_policy.insert_another_unvisited_site()@\\
\mbox{}\verb@debug(Fore.GREEN + "Inserted another unvisited site" + Style.RESET_ALL)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk When using Python 2.7 (as I am doing with this suite of programs), you should have the 
\texttt{pyyaml} module version 3.12 installed. Version 4.1 breaks for some weird reason; it can't seem to serialized
Numpy objects. See \url{https://github.com/kevin1024/vcrpy/issues/366} for a brief discussion on this topic. 

The version of \verb|pyyaml| on your machine can be checked by printing the value of \verb|yaml.__version__|. 
To install the correct version of pyyaml (if you get errors)  use

\begin{verbatim} 
              sudo pip uninstall pyyaml && sudo pip install pyyaml=3.12
\end{verbatim}

\newchunk We use the \verb|write_algo_states_to_disk_p| boolean argument to explicitly specify whether to write 
the current algorithm state along with its image to disk or not. This is because Matplotlib and PyYaml
is \underline{very} slow when writing image files to disk. Later on, I will probably switch to Asymptote 
for all my plotting, but for the moment I will stick to Matplotlib because I don't want to have to switch languages right now. 
 
And much of my plots will be of a reasonably high-quality for the purpose of presentations. This will naturally 
affect timing/benchmarking results. 

\begin{flushleft} \small\label{scrap29}\raggedright\small
\NWtarget{nuweb35a}{} $\langle\,${\itshape Write algorithm's current state to file}\nobreak\ {\footnotesize {35a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if write_algo_states_to_disk_p:@\\
\mbox{}\verb@     import yaml@\\
\mbox{}\verb@     algo_state_file_name = 'algo_state_'                    + \@\\
\mbox{}\verb@                       str(algo_state_counter).zfill(5) + \@\\
\mbox{}\verb@                       '.yml'@\\
\mbox{}\verb@@\\
\mbox{}\verb@     data = {'insertion_policy_name' : insertion_policy_name                       ,@\\
\mbox{}\verb@             'unvisited_sites'       : [insertion_policy.sites[u] \@\\
\mbox{}\verb@                                            for u in insertion_policy.unvisited_sites_idxs], @\\
\mbox{}\verb@             'visited_sites'         : insertion_policy.visited_sites                    , @\\
\mbox{}\verb@             'horse_tour'            : insertion_policy.horse_tour }@\\
\mbox{}\verb@@\\
\mbox{}\verb@     with open(dir_name + '/' + algo_state_file_name, 'w') as outfile:@\\
\mbox{}\verb@          yaml.dump( data   , \@\\
\mbox{}\verb@                     outfile, \@\\
\mbox{}\verb@                     default_flow_style = False)@\\
\mbox{}\verb@          @\hbox{$\langle\,${\itshape Render current algorithm state to image file}\nobreak\ {\footnotesize \NWlink{nuweb35b}{35b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@     algo_state_counter = algo_state_counter + 1@\\
\mbox{}\verb@     debug("Dumped algorithm state to " + algo_state_file_name)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}, \verb@write_algo_states_to_disk_p@\nobreak\ \NWlink{nuweb33a}{33a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.4cm}

\begin{flushleft} \small\label{scrap30}\raggedright\small
\NWtarget{nuweb35b}{} $\langle\,${\itshape Render current algorithm state to image file}\nobreak\ {\footnotesize {35b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@import utils_algo@\\
\mbox{}\verb@if write_algo_states_to_disk_p:@\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Set up plotting area and canvas, fig, ax, and other configs}\nobreak\ {\footnotesize \NWlink{nuweb35c}{35c}}$\,\rangle$}\verb@  @\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Extract $x$ and $y$ coordinates of the points on the horse, fly tours, visited and unvisited sites}\nobreak\ {\footnotesize \NWlink{nuweb36a}{36a}}$\,\rangle$}\verb@  @\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Mark initial position of horse and fly boldly on canvas}\nobreak\ {\footnotesize \NWlink{nuweb36b}{36b}}$\,\rangle$}\verb@  @\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Place numbered markers on visited sites to mark the order of visitation explicitly}\nobreak\ {\footnotesize \NWlink{nuweb37b}{37b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Draw horse and fly-tours}\nobreak\ {\footnotesize \NWlink{nuweb37a}{37a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Draw unvisited sites as filled blue circles}\nobreak\ {\footnotesize \NWlink{nuweb37c}{37c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Give metainformation about current picture as headers and footers}\nobreak\ {\footnotesize \NWlink{nuweb37d}{37d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@     @\hbox{$\langle\,${\itshape Write image file}\nobreak\ {\footnotesize \NWlink{nuweb37e}{37e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@write_algo_states_to_disk_p@\nobreak\ \NWlink{nuweb33a}{33a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap31}\raggedright\small
\NWtarget{nuweb35c}{} $\langle\,${\itshape Set up plotting area and canvas, fig, ax, and other configs}\nobreak\ {\footnotesize {35c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@rc('font', **{'family': 'serif', \@\\
\mbox{}\verb@           'serif': ['Computer Modern']})@\\
\mbox{}\verb@rc('text', usetex=True)@\\
\mbox{}\verb@fig,ax = plt.subplots()@\\
\mbox{}\verb@ax.set_xlim([0,1])@\\
\mbox{}\verb@ax.set_ylim([0,1])@\\
\mbox{}\verb@ax.set_aspect(1.0)@\\
\mbox{}\verb@ax = fig.gca()@\\
\mbox{}\verb@ax.set_xticks(np.arange(0, 1, 0.1))     @\\
\mbox{}\verb@ax.set_yticks(np.arange(0, 1., 0.1))@\\
\mbox{}\verb@plt.grid(linestyle='dotted')@\\
\mbox{}\verb@ax.set_xticklabels([]) # to remove those numbers at the bottom@\\
\mbox{}\verb@ax.set_yticklabels([])@\\
\mbox{}\verb@@\\
\mbox{}\verb@ax.tick_params(@\\
\mbox{}\verb@    bottom=False,      # ticks along the bottom edge are off@\\
\mbox{}\verb@    left=False,        # ticks along the top edge are off@\\
\mbox{}\verb@    labelbottom=False) # labels along the bottom edge are off@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk Matplotlib typically plots points using x and y coordinates of the points in separate points. 
\begin{flushleft} \small\label{scrap32}\raggedright\small
\NWtarget{nuweb36a}{} $\langle\,${\itshape Extract $x$ and $y$ coordinates of the points on the horse, fly tours, visited and unvisited sites}\nobreak\ {\footnotesize {36a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# Route for the horse@\\
\mbox{}\verb@xhs = [ data['horse_tour'][i][0] \@\\
\mbox{}\verb@          for i in range(len(data['horse_tour']))  ]    @\\
\mbox{}\verb@yhs = [ data['horse_tour'][i][1] \@\\
\mbox{}\verb@          for i in range(len(data['horse_tour']))  ]    @\\
\mbox{}\verb@@\\
\mbox{}\verb@# Route for the fly. The fly keeps alternating between the site and the horse@\\
\mbox{}\verb@xfs , yfs = [xhs[0]], [yhs[0]]@\\
\mbox{}\verb@for site, pt in zip (data['visited_sites'],@\\
\mbox{}\verb@                     data['horse_tour'][1:]):@\\
\mbox{}\verb@    xfs.extend([site[0], pt[0]])@\\
\mbox{}\verb@    yfs.extend([site[1], pt[1]])@\\
\mbox{}\verb@        @\\
\mbox{}\verb@xvisited = [ data['visited_sites'][i][0] \@\\
\mbox{}\verb@               for i in range(len(data['visited_sites']))  ]    @\\
\mbox{}\verb@yvisited = [ data['visited_sites'][i][1] \@\\
\mbox{}\verb@               for i in range(len(data['visited_sites']))  ]    @\\
\mbox{}\verb@    @\\
\mbox{}\verb@xunvisited = [ data['unvisited_sites'][i][0] \@\\
\mbox{}\verb@                 for i in range(len(data['unvisited_sites']))  ]    @\\
\mbox{}\verb@yunvisited = [ data['unvisited_sites'][i][1] @\\
\mbox{}\verb@                 for i in range(len(data['unvisited_sites'])) ]    @\\
\mbox{}\verb@debug("Extracted x and y coordinates for route of horse, fly, visited and unvisited sites")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.
\item \NWtxtIdentsUsed\nobreak\  \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap33}\raggedright\small
\NWtarget{nuweb36b}{} $\langle\,${\itshape Mark initial position of horse and fly boldly on canvas}\nobreak\ {\footnotesize {36b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@ax.add_patch( mpl.patches.Circle( inithorseposn, \@\\
\mbox{}\verb@                                  radius = 1/55.0,\@\\
\mbox{}\verb@                                  facecolor= '#D13131', #'red',\@\\
\mbox{}\verb@                                  edgecolor='black')  )@\\
\mbox{}\verb@debug("Marked the initial position of horse and fly on canvas")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap34}\raggedright\small
\NWtarget{nuweb37a}{} $\langle\,${\itshape Draw horse and fly-tours}\nobreak\ {\footnotesize {37a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@ax.plot(xfs,yfs,'g-',linewidth=1.1)  @\\
\mbox{}\verb@ax.plot(xhs, yhs, color='r', \@\\
\mbox{}\verb@        marker='s', markersize=3, \@\\
\mbox{}\verb@        linewidth=1.6) @\\
\mbox{}\verb@debug("Plotted the horse and fly tours")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small\label{scrap35}\raggedright\small
\NWtarget{nuweb37b}{} $\langle\,${\itshape Place numbered markers on visited sites to mark the order of visitation explicitly}\nobreak\ {\footnotesize {37b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@for x,y,i in zip(xvisited, yvisited, range(len(xvisited))):@\\
\mbox{}\verb@     ax.text(x, y, str(i+1),  fontsize=8, \@\\
\mbox{}\verb@             bbox=dict(facecolor='#ddcba0', alpha=1.0, pad=2.0)) @\\
\mbox{}\verb@debug("Placed numbered markers on visited sites")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small\label{scrap36}\raggedright\small
\NWtarget{nuweb37c}{} $\langle\,${\itshape Draw unvisited sites as filled blue circles}\nobreak\ {\footnotesize {37c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@for x, y in zip(xunvisited, yunvisited):@\\
\mbox{}\verb@     ax.add_patch( mpl.patches.Circle( (x,y),\@\\
\mbox{}\verb@                                    radius    = 1/100.0,\@\\
\mbox{}\verb@                                    facecolor = 'blue',\@\\
\mbox{}\verb@                                    edgecolor = 'black')  )@\\
\mbox{}\verb@debug("Drew univisted sites")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap37}\raggedright\small
\NWtarget{nuweb37d}{} $\langle\,${\itshape Give metainformation about current picture as headers and footers}\nobreak\ {\footnotesize {37d}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@fontsize = 15@\\
\mbox{}\verb@ax.set_title( r'Number of sites visited so far: ' +\@\\
\mbox{}\verb@               str(len(data['visited_sites']))   +\@\\
\mbox{}\verb@               '/' + str(len(sites))           ,  \@\\
\mbox{}\verb@                    fontdict={'fontsize':fontsize})@\\
\mbox{}\verb@ax.set_xlabel(r'$\varphi=$'+str(phi), fontdict={'fontsize':fontsize})@\\
\mbox{}\verb@debug("Setting title, headers, footers, etc...")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}
Note that after writing image files, you should close the current figure. Otherwise
the collection of all the open figures starts hogging the RAM. Matplotlib throws a
a warning to this effect (if you don't close to the figures) after writing about 
20 figures:

\begin{CVerbatim}[fontsize=\small]
/usr/local/lib/python2.7/dist-packages/matplotlib/pyplot.py:528: RuntimeWarning: 
More than 20 figures have been opened. Figures created through the pyplot interface 
(`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume 
too much memory. (To control this warning, see the rcParam `figure.max_open_warning`).
max_open_warning, RuntimeWarning)
\end{CVerbatim}

There is a  Stack Overflow answer (\url{https://stackoverflow.com/a/21884375/505306}) 
which advises to call \verb|plt.close()| after writing out a file that closes the 
\textit{current} figure to avoid the above warning. 

\begin{flushleft} \small\label{scrap38}\raggedright\small
\NWtarget{nuweb37e}{} $\langle\,${\itshape Write image file}\nobreak\ {\footnotesize {37e}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@image_file_name = 'algo_state_'                    +\@\\
\mbox{}\verb@                  str(algo_state_counter).zfill(5) +\@\\
\mbox{}\verb@                     '.png'@\\
\mbox{}\verb@plt.savefig(dir_name + '/' + image_file_name,  \@\\
\mbox{}\verb@            bbox_inches='tight', dpi=250)@\\
\mbox{}\verb@print "Wrote " + image_file_name + " to disk"   @\\
\mbox{}\verb@plt.close() @\\
\mbox{}\verb@debug(Fore.BLUE+"Rendered algorithm state to image file"+Style.RESET_ALL)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35b}{35b}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk The final answer is written to disk in the form of a YAML file. It lists the input sites 
in the order of visitation computed by the algorithm and gives the tour of the horse. 
Note that the number of points on the horse's tour is 1 more than the number of given sites. 

\begin{flushleft} \small\label{scrap39}\raggedright\small
\NWtarget{nuweb38a}{} $\langle\,${\itshape Write input and output to file}\nobreak\ {\footnotesize {38a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# ASSERT: `inithorseposn` is included as first point of the tour@\\
\mbox{}\verb@assert(len(insertion_policy.horse_tour) == len(insertion_policy.visited_sites) + 1) @\\
\mbox{}\verb@@\\
\mbox{}\verb@# ASSERT: All sites have been visited. Simple sanity check @\\
\mbox{}\verb@assert(len(insertion_policy.sites)   == len(insertion_policy.visited_sites)) @\\
\mbox{}\verb@@\\
\mbox{}\verb@data = {'insertion_policy_name' : insertion_policy_name   ,@\\
\mbox{}\verb@        'visited_sites'  : insertion_policy.visited_sites , @\\
\mbox{}\verb@        'horse_tour'     : insertion_policy.horse_tour    , @\\
\mbox{}\verb@        'phi'            : insertion_policy.phi           , @\\
\mbox{}\verb@        'inithorseposn'  : insertion_policy.inithorseposn}@\\
\mbox{}\verb@@\\
\mbox{}\verb@import yaml@\\
\mbox{}\verb@with open(dir_name + '/' + io_file_name, 'w') as outfile:     yaml.dump( data, \@\\
\mbox{}\verb@                outfile, \@\\
\mbox{}\verb@                default_flow_style=False)@\\
\mbox{}\verb@debug("Dumped input and output to " + io_file_name)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}, \verb@io_file_name,@\nobreak\ \NWlink{nuweb33b}{33b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk If algorithm states have been rendered to files in the run-folder, we stitch them together using \verb|ffmpeg|
and make an \verb|.mp4| animation of the changing states of the algorithms. The \verb|.mp4| file will be in the algorithm's
run folder. I used the  tutorial given on \url{https://en.wikibooks.org/wiki/FFMPEG_An_Intermediate_Guide/image_sequence}
for choosing the particular command-line options to \verb|ffmpeg| below. The options \texttt{-hide\_banner -loglevel panic} 
to quieten \verb|ffmpeg|'s output were suggested by  \url{https://superuser.com/a/1045060/102371} 


\begin{flushleft} \small\label{scrap40}\raggedright\small
\NWtarget{nuweb38b}{} $\langle\,${\itshape Make an animation of algorithm states, if \verb|write_algo_states_to_disk_p == True|}\nobreak\ {\footnotesize {38b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if write_algo_states_to_disk_p:@\\
\mbox{}\verb@     import subprocess, os@\\
\mbox{}\verb@     os.chdir(dir_name)@\\
\mbox{}\verb@     subprocess.call( ['ffmpeg',  '-hide_banner', '-loglevel', 'verbose', \@\\
\mbox{}\verb@                       '-r', '1',  '-i', 'algo_state_%05d.png', \@\\
\mbox{}\verb@                       '-vcodec', 'mpeg4', '-r', '10' , \@\\
\mbox{}\verb@                       'algo_state_animation.avi']  )@\\
\mbox{}\verb@     os.chdir('../')@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@write_algo_states_to_disk_p@\nobreak\ \NWlink{nuweb33a}{33a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm} \newchunk This chunks reads the information in the input-output file just written out as
a YAML file in the run-folder and then renders the process of the horse and fly moving around the plane 
delivering packages to sites. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap41}\raggedright\small
\NWtarget{nuweb39a}{} $\langle\,${\itshape Make an animation of the schedule, if \verb|animate_schedule_p == True|}\nobreak\ {\footnotesize {39a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@if animate_schedule_p : @\\
\mbox{}\verb@     animateSchedule(dir_name + '/' + io_file_name)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap42}\raggedright\small
\NWtarget{nuweb39b}{} $\langle\,${\itshape Return horsefly tour, along with additional information}\nobreak\ {\footnotesize {39b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@debug("Returning answer")@\\
\mbox{}\verb@horse_waiting_times = np.zeros(len(sites)) # TODO write this to file later@\\
\mbox{}\verb@return {'tour_points'                : insertion_policy.horse_tour[1:],@\\
\mbox{}\verb@        'horse_waiting_times'        : horse_waiting_times, @\\
\mbox{}\verb@        'site_ordering'              : insertion_policy.visited_sites,@\\
\mbox{}\verb@        'tour_length_with_waiting_time_included': \@\\
\mbox{}\verb@                                       tour_length_with_waiting_time_included(\@\\
\mbox{}\verb@                                                    insertion_policy.horse_tour[1:], \@\\
\mbox{}\verb@                                                    horse_waiting_times, \@\\
\mbox{}\verb@                                                    inithorseposn)}@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}, \verb@tour_length_with_waiting_time_included@\nobreak\ \NWlink{nuweb44b}{44b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk We now define some of the functions that were referred to in the above chunks. 
Given the intial position of the truck and drone, and a list of sites, we need to compute 
the collinear horsefly tour length for the given ordering. This is the function that is 
used in every policy class while deciding which is the cheapest unvisited site to insert 
into the current ordering of visited sites. 

Note that the order in which sites are passed to this function matters. It 
assumes that you want to compute the collinear horseflies tour length for the 
sites \textit{in the given order.} 

For this, we use the formula for computing the rendezvous point when there is 
only a single site, given by the code-chunk below. 

%\begin{center}
%\missingfigure[figwidth=6cm]{Sigle site analytic}
%\end{center}

\begin{flushleft} \small\label{scrap43}\raggedright\small
\NWtarget{nuweb39c}{} $\langle\,${\itshape Define auxiliary helper functions}\nobreak\ {\footnotesize {39c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def single_site_solution(site, horseposn, phi):@\\
\mbox{}\verb@     @\\
\mbox{}\verb@     h = np.asarray(horseposn)@\\
\mbox{}\verb@     s = np.asarray(site)@\\
\mbox{}\verb@     @\\
\mbox{}\verb@     hs_mag  = 1.0/np.linalg.norm(s-h) @\\
\mbox{}\verb@     hs_unit = 1.0/hs_mag * (s-h)@\\
\mbox{}\verb@     @\\
\mbox{}\verb@     r      = h +  2*hs_mag/(1+phi) * hs_unit # Rendezvous point@\\
\mbox{}\verb@     hr_mag = np.linalg.norm(r-h)@\\
\mbox{}\verb@@\\
\mbox{}\verb@     return (tuple(r), hr_mag) @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb39c}{39c}\NWlink{nuweb40a}{, 40a}\NWlink{nuweb40b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@single_site_solution@\nobreak\ \NWlink{nuweb40a}{40a}\NWlink{nuweb40b}{b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}
With that the tour length functions for collinear horseflies can be implemented as 
an elementary instance of the fold pattern of functional programming. 
\footnote{Python has folds tucked away in some corner of its standard library. 
But I am not using it during the first hacky portion of this draft. Also Shane 
mentioned it has performance issues? Double-check this later!}
\begin{flushleft} \small\label{scrap44}\raggedright\small
\NWtarget{nuweb40a}{} $\langle\,${\itshape Define auxiliary helper functions}\nobreak\ {\footnotesize {40a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def compute_collinear_horseflies_tour_length(sites, horseposn, phi):@\\
\mbox{}\verb@@\\
\mbox{}\verb@     if not sites: # No more sites, left to visit!@\\
\mbox{}\verb@          return 0@\\
\mbox{}\verb@     else:         # Some sites are still left on the itinerary@\\
\mbox{}\verb@@\\
\mbox{}\verb@          (rendezvous_pt, horse_travel_length) = single_site_solution(sites[0], horseposn, phi )@\\
\mbox{}\verb@          return horse_travel_length  + \@\\
\mbox{}\verb@                 compute_collinear_horseflies_tour_length( sites[1:], rendezvous_pt, phi )@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb39c}{39c}\NWlink{nuweb40a}{, 40a}\NWlink{nuweb40b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@compute_collinear_horseflies_tour_length@\nobreak\ \NWlink{nuweb41c}{41c}\NWlink{nuweb42b}{, 42b}.\item \NWtxtIdentsUsed\nobreak\  \verb@single_site_solution@\nobreak\ \NWlink{nuweb39c}{39c}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap45}\raggedright\small
\NWtarget{nuweb40b}{} $\langle\,${\itshape Define auxiliary helper functions}\nobreak\ {\footnotesize {40b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def compute_collinear_horseflies_tour(sites, inithorseposn, phi):@\\
\mbox{}\verb@@\\
\mbox{}\verb@      horseposn         = inithorseposn@\\
\mbox{}\verb@      horse_tour_points = [inithorseposn]@\\
\mbox{}\verb@@\\
\mbox{}\verb@      for site in sites:@\\
\mbox{}\verb@          (rendezvous_pt, _) = single_site_solution(site, horseposn, phi )@\\
\mbox{}\verb@            @\\
\mbox{}\verb@          horse_tour_points.append(rendezvous_pt)@\\
\mbox{}\verb@          horseposn = rendezvous_pt@\\
\mbox{}\verb@@\\
\mbox{}\verb@      return horse_tour_points@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb39c}{39c}\NWlink{nuweb40a}{, 40a}\NWlink{nuweb40b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@compute_collinear_horseflies_tour@\nobreak\ \NWlink{nuweb43}{43}.\item \NWtxtIdentsUsed\nobreak\  \verb@single_site_solution@\nobreak\ \NWlink{nuweb39c}{39c}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Insertion Policies} 
\label{subsec:insertion-policies}

We have finished implemented the entire algorithm, except 
for the implementation of the various insertion policy classes. 

The main job of an insertion policy class is to keep track 
of the  unvisited sites,  the order of the visited sites and the 
horsefly tour itself. Every time, the method \verb|.get_next_site(...)| is called, it 
chooses an appropriate (i.e. cheapest) unvisited site to insert 
into the current ordering, and update the set of visited and unvisited sites
and details of the horsefly tour.  

To do this quickly it will typically need auxiliary data-structures whose specifics 
will depend on the details of the policy chosen. 

\subsection{Naive Insertion} \quad First, a naive implementation
  of the cheapest insertion heuristic, that will be useful in future
  benchmarking of running times and solution quality for implementations 
  that are quicker but make more sophisticated uses of data-structures. 

  In this policy for each unvisited site we first find the 
  position in the current tour, which after insertion into that position
  amongst the visited sites yields the smallest increase in the 
  collinear-horseflies tour-length. 

  Then we pick the unvisited site which yields the overall smallest 
  increase in tour-length and insert it into its computed position
  from its previous paragraph. 
     
  Clearly this implementation and has at least quadratic running time. 
  Later on, we will be investigating algorithms and data-structures 
  for speeding up this operation. 

  The hope is to be able to find a dynamic data-structure to perform this 
  insertion in logarithmic time. Variations on tools such as the well-separated pair 
  decomposition might help achieve this goal. Jon Bentley
  used kd-trees to perform the insertion in his experimental TSP
  paper, but he wasn't dealing with the shifting tour structure
  as we have in horseflies. Also he did not deal with the question 
  of finding an approximate point for insertion. These 

\newchunk Since the interface for all policy classes will be the same, it is 
best, if have a base class for such classes. Since the details of 
the interface may change, I'll probably do this later. For now, 
I'll just keep all the policy classes completely separate while 
keeping the interface of the constructors and methods the same. 
I'll refactor things later. 

The plan in that case should be to make an abstract class that 
has an abstract method called \texttt{insert\_unvisited\_site}
and three data-fields made from the base-constructor named \texttt{sites}, \texttt{inithorseposn}
and \texttt{phi}. Classes which inherit this abstract base class, will 
add their own local data-members and methods for keeping track of 
data for insertion. 

\begin{flushleft} \small\label{scrap46}\raggedright\small
\NWtarget{nuweb41a}{} $\langle\,${\itshape Define various insertion policy classes}\nobreak\ {\footnotesize {41a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@class PolicyBestInsertionNaive:@\\
\mbox{}\verb@@\\
\mbox{}\verb@    def __init__(self, sites, inithorseposn, phi):@\\
\mbox{}\verb@@\\
\mbox{}\verb@         self.sites           = sites@\\
\mbox{}\verb@         self.inithorseposn   = inithorseposn@\\
\mbox{}\verb@         self.phi             = phi@\\
\mbox{}\verb@@\\
\mbox{}\verb@         self.visited_sites        = []                # The actual list of visited sites (not indices)@\\
\mbox{}\verb@         self.unvisited_sites_idxs = range(len(sites)) # This indexes into self.sites@\\
\mbox{}\verb@         self.horse_tour           = [self.inithorseposn]         @\\
\mbox{}\verb@@\\
\mbox{}\verb@    @\hbox{$\langle\,${\itshape Methods for \verb|PolicyBestInsertionNaive|}\nobreak\ {\footnotesize \NWlink{nuweb41b}{41b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb33a}{33a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@self.horse_tour@\nobreak\ \NWlink{nuweb43}{43}, \verb@self.inithorseposn,@\nobreak\ \NWlink{nuweb25b}{25b}\NWlink{nuweb41c}{, 41c}\NWlink{nuweb42b}{, 42b}\NWlink{nuweb43}{, 43}, \verb@self.sites,@\nobreak\ \NWlink{nuweb25b}{25b}, \verb@self.visited_sites,@\nobreak\ \NWlink{nuweb41c}{41c}\NWlink{nuweb43}{, 43}.\item \NWtxtIdentsUsed\nobreak\  \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap47}\raggedright\small
\NWtarget{nuweb41b}{} $\langle\,${\itshape Methods for \verb|PolicyBestInsertionNaive|}\nobreak\ {\footnotesize {41b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def insert_another_unvisited_site(self):@\\
\mbox{}\verb@   @\hbox{$\langle\,${\itshape Compute the length of the tour that currently services the visited sites}\nobreak\ {\footnotesize \NWlink{nuweb41c}{41c}}$\,\rangle$}\verb@    @\\
\mbox{}\verb@   delta_increase_least_table = [] # tracking variable updated in for loop below@\\
\mbox{}\verb@@\\
\mbox{}\verb@   for u in self.unvisited_sites_idxs:@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Set up tracking variables local to this iteration}\nobreak\ {\footnotesize \NWlink{nuweb42a}{42a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape If \texttt{self.sites[u]} is chosen for insertion, find best insertion position and update \texttt{delta\_increase\_least\_table}}\nobreak\ {\footnotesize \NWlink{nuweb42b}{42b}}$\,\rangle$}\verb@  @\\
\mbox{}\verb@                 @\\
\mbox{}\verb@   @\hbox{$\langle\,${\itshape Find the unvisited site which on insertion increases tour-length by the least amount}\nobreak\ {\footnotesize \NWlink{nuweb42c}{42c}}$\,\rangle$}\verb@     @\\
\mbox{}\verb@   @\hbox{$\langle\,${\itshape Update states for \texttt{PolicyBestInsertionNaive}}\nobreak\ {\footnotesize \NWlink{nuweb43}{43}}$\,\rangle$}\verb@ @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41a}{41a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@delta_increase_least_table@\nobreak\ \NWlink{nuweb42b}{42b}\NWlink{nuweb42c}{c}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 

\begin{flushleft} \small\label{scrap48}\raggedright\small
\NWtarget{nuweb41c}{} $\langle\,${\itshape Compute the length of the tour that currently services the visited sites}\nobreak\ {\footnotesize {41c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@current_tour_length    = \@\\
\mbox{}\verb@         compute_collinear_horseflies_tour_length(\@\\
\mbox{}\verb@                    self.visited_sites,\@\\
\mbox{}\verb@                    self.inithorseposn,\@\\
\mbox{}\verb@                    self.phi) @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\item \NWtxtIdentsDefed\nobreak\  \verb@current_tour_length@\nobreak\ \NWlink{nuweb42b}{42b}.\item \NWtxtIdentsUsed\nobreak\  \verb@compute_collinear_horseflies_tour_length@\nobreak\ \NWlink{nuweb40a}{40a}, \verb@self.inithorseposn,@\nobreak\ \NWlink{nuweb41a}{41a}, \verb@self.visited_sites,@\nobreak\ \NWlink{nuweb41a}{41a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap49}\raggedright\small
\NWtarget{nuweb42a}{} $\langle\,${\itshape Set up tracking variables local to this iteration}\nobreak\ {\footnotesize {42a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@ibest                = 0@\\
\mbox{}\verb@delta_increase_least = float("inf")@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\item \NWtxtIdentsDefed\nobreak\  \verb@delta_increase_least@\nobreak\ \NWlink{nuweb42b}{42b}, \verb@ibest,@\nobreak\ \NWlink{nuweb42b}{42b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap50}\raggedright\small
\NWtarget{nuweb42b}{} $\langle\,${\itshape If \texttt{self.sites[u]} is chosen for insertion, find best insertion position and update \texttt{delta\_increase\_least\_table}}\nobreak\ {\footnotesize {42b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@for i in range(len(self.sites)):@\\
\mbox{}\verb@                    @\\
\mbox{}\verb@            visited_sites_test = self.visited_sites[:i] +\@\\
\mbox{}\verb@                                 [ self.sites[u] ]      +\@\\
\mbox{}\verb@                                 self.visited_sites[i:]@\\
\mbox{}\verb@                                      @\\
\mbox{}\verb@            tour_length_on_insertion = \@\\
\mbox{}\verb@                       compute_collinear_horseflies_tour_length(\@\\
\mbox{}\verb@                                  visited_sites_test,\@\\
\mbox{}\verb@                                  self.inithorseposn,\@\\
\mbox{}\verb@                                  self.phi) @\\
\mbox{}\verb@@\\
\mbox{}\verb@            delta_increase = tour_length_on_insertion - current_tour_length                         @\\
\mbox{}\verb@            assert(delta_increase >= 0)               @\\
\mbox{}\verb@@\\
\mbox{}\verb@            if delta_increase < delta_increase_least:@\\
\mbox{}\verb@                  delta_increase_least = delta_increase@\\
\mbox{}\verb@                  ibest                = i                                              @\\
\mbox{}\verb@                      @\\
\mbox{}\verb@delta_increase_least_table.append({'unvisited_site_idx'      : u    , \@\\
\mbox{}\verb@                                   'best_insertion_position' : ibest, \@\\
\mbox{}\verb@                                   'delta_increase'          : delta_increase_least})@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\item \NWtxtIdentsUsed\nobreak\  \verb@compute_collinear_horseflies_tour_length@\nobreak\ \NWlink{nuweb40a}{40a}, \verb@current_tour_length@\nobreak\ \NWlink{nuweb41c}{41c}, \verb@delta_increase_least@\nobreak\ \NWlink{nuweb42a}{42a}, \verb@delta_increase_least_table@\nobreak\ \NWlink{nuweb41b}{41b}, \verb@ibest,@\nobreak\ \NWlink{nuweb42a}{42a}, \verb@self.inithorseposn,@\nobreak\ \NWlink{nuweb41a}{41a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap51}\raggedright\small
\NWtarget{nuweb42c}{} $\langle\,${\itshape Find the unvisited site which on insertion increases tour-length by the least amount}\nobreak\ {\footnotesize {42c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@best_table_entry = min(delta_increase_least_table, \@\\
\mbox{}\verb@                         key = lambda x: x['delta_increase'])@\\
\mbox{}\verb@         @\\
\mbox{}\verb@unvisited_site_idx_for_insertion = best_table_entry['unvisited_site_idx']@\\
\mbox{}\verb@insertion_position               = best_table_entry['best_insertion_position']@\\
\mbox{}\verb@delta_increase                   = best_table_entry['delta_increase']@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\item \NWtxtIdentsUsed\nobreak\  \verb@delta_increase_least_table@\nobreak\ \NWlink{nuweb41b}{41b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small\label{scrap52}\raggedright\small
\NWtarget{nuweb43}{} $\langle\,${\itshape Update states for \texttt{PolicyBestInsertionNaive}}\nobreak\ {\footnotesize {43}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# Update visited and univisted sites info@\\
\mbox{}\verb@self.visited_sites = self.visited_sites[:insertion_position]      +\@\\
\mbox{}\verb@                     [self.sites[unvisited_site_idx_for_insertion]] +\@\\
\mbox{}\verb@                     self.visited_sites[insertion_position:]@\\
\mbox{}\verb@  @\\
\mbox{}\verb@self.unvisited_sites_idxs = filter( lambda elt: elt != unvisited_site_idx_for_insertion, \@\\
\mbox{}\verb@                                    self.unvisited_sites_idxs ) @\\
\mbox{}\verb@@\\
\mbox{}\verb@# Update the tour of the horse@\\
\mbox{}\verb@self.horse_tour = compute_collinear_horseflies_tour(\@\\
\mbox{}\verb@                           self.visited_sites,         \@\\
\mbox{}\verb@                           self.inithorseposn, \@\\
\mbox{}\verb@                           self.phi) @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\item \NWtxtIdentsUsed\nobreak\  \verb@compute_collinear_horseflies_tour@\nobreak\ \NWlink{nuweb40b}{40b}, \verb@horse_tour@\nobreak\ \NWlink{nuweb47b}{47b}, \verb@self.horse_tour@\nobreak\ \NWlink{nuweb41a}{41a}, \verb@self.inithorseposn,@\nobreak\ \NWlink{nuweb41a}{41a}, \verb@self.visited_sites,@\nobreak\ \NWlink{nuweb41a}{41a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Algorithm: Bottom-Up Split}  

\subsection{Algorithmic Overview}
\subsection{Algorithmic Details}\section{Algorithm: Local Search---Swap}  
\subsection{Algorithmic Overview}
\subsection{Algorithmic Details}
\section{Algorithm: K2 Means}  

\subsection{Algorithmic Overview}
\subsection{Algorithmic Details}

\section{Lower Bound: $\varphi$-MST}

\subsection{Overview}
\subsection{Computing the Lower-Bound}

\section{Local Utility Functions}

\newchunk  For a given initial position of horse and fly
   return a function computing the tour length. 
   The returned function computes the tour length 
   in the order of the list of stops provided beginning 
   with the initial position of horse and fly. Since 
   the horse speed = 1, the tour length = time taken 
   by horse to traverse the route.

   This is in other words the objective function. 

\begin{flushleft} \small\label{scrap53}\raggedright\small
\NWtarget{nuweb44a}{} $\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize {44a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def tour_length(horseflyinit):@\\
\mbox{}\verb@   def _tourlength (x):@\\
\mbox{}\verb@         @\\
\mbox{}\verb@        # the first point on the tour is the@\\
\mbox{}\verb@        # initial position of horse and fly@\\
\mbox{}\verb@        # Append this to the solution x = [x0,x1,x2,....]@\\
\mbox{}\verb@        # at the front@\\
\mbox{}\verb@        htour = np.append(horseflyinit, x)@\\
\mbox{}\verb@        length = 0 @\\
\mbox{}\verb@@\\
\mbox{}\verb@        for i in range(len(htour))[:-3:2]:@\\
\mbox{}\verb@                length = length + \@\\
\mbox{}\verb@                         np.linalg.norm([htour[i+2] - htour[i], \@\\
\mbox{}\verb@                                         htour[i+3] - htour[i+1]]) @\\
\mbox{}\verb@        return length@\\
\mbox{}\verb@@\\
\mbox{}\verb@   return _tourlength@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb44a}{44a}\NWlink{nuweb44b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@tour_length@\nobreak\ \NWlink{nuweb27}{27}\NWlink{nuweb29}{, 29}\NWlink{nuweb45}{, 45}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk It is possible that some heuristics might return non-negligible
      waiting times. Hence I am writing a separate function which
      adds the waiting time (if it is positive) to the length of 
      each link of the tour. Again note that because 
      speed of horse = 1, we can add ``time'' to ``distance''. 

\begin{flushleft} \small\label{scrap54}\raggedright\small
\NWtarget{nuweb44b}{} $\langle\,${\itshape Local utility functions for classic horsefly}\nobreak\ {\footnotesize {44b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def tour_length_with_waiting_time_included(tour_points, horse_waiting_times, horseflyinit):@\\
\mbox{}\verb@      tour_points   = np.asarray([horseflyinit] + tour_points)@\\
\mbox{}\verb@      tour_links    = zip(tour_points, tour_points[1:])@\\
\mbox{}\verb@@\\
\mbox{}\verb@      # the +1 because the inital position has been tacked on at the beginning@\\
\mbox{}\verb@      # the solvers written the tour points except for the starting position@\\
\mbox{}\verb@      # because that is known and part of the input. For this function@\\
\mbox{}\verb@      # I need to tack it on for tour length@\\
\mbox{}\verb@      assert(len(tour_points) == len(horse_waiting_times)+1) @\\
\mbox{}\verb@@\\
\mbox{}\verb@      sum = 0@\\
\mbox{}\verb@      for i in range(len(horse_waiting_times)):@\\
\mbox{}\verb@@\\
\mbox{}\verb@          # Negative waiting times means drone/fly was waiting@\\
\mbox{}\verb@          # at rendezvous point@\\
\mbox{}\verb@          if horse_waiting_times[i] >= 0:@\\
\mbox{}\verb@              wait = horse_waiting_times[i]@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              wait = 0@\\
\mbox{}\verb@              @\\
\mbox{}\verb@          sum += wait + np.linalg.norm(tour_links[i][0] - tour_links[i][1], ord=2) # @\\
\mbox{}\verb@      return sum@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb44a}{44a}\NWlink{nuweb44b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@tour_length_with_waiting_time_included@\nobreak\ \NWlink{nuweb29}{29}\NWlink{nuweb39b}{, 39b}\NWlink{nuweb45}{, 45}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Plotting Routines}
\newchunk 
\begin{flushleft} \small\label{scrap55}\raggedright\small
\NWtarget{nuweb45}{} $\langle\,${\itshape Plotting routines for classic horsefly}\nobreak\ {\footnotesize {45}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def plotTour(ax,horseflytour, horseflyinit, phi, algo_str, tour_color='#d13131'):@\\
\mbox{}\verb@   @\\
\mbox{}\verb@    # Route for the horse@\\
\mbox{}\verb@    xhs, yhs = [horseflyinit[0]], [horseflyinit[1]]@\\
\mbox{}\verb@    for pt in horseflytour['tour_points']:@\\
\mbox{}\verb@        xhs.append(pt[0])@\\
\mbox{}\verb@        yhs.append(pt[1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # List of sites@\\
\mbox{}\verb@    xsites, ysites = [], []@\\
\mbox{}\verb@    for pt in horseflytour['site_ordering']:@\\
\mbox{}\verb@        xsites.append(pt[0])@\\
\mbox{}\verb@        ysites.append(pt[1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Route for the fly. The fly keeps alternating@\\
\mbox{}\verb@    # between the site and the horse@\\
\mbox{}\verb@    xfs , yfs = [xhs[0]], [yhs[0]]@\\
\mbox{}\verb@    for site, pt in zip (horseflytour['site_ordering'],@\\
\mbox{}\verb@                         horseflytour['tour_points']):@\\
\mbox{}\verb@        xfs.extend([site[0], pt[0]])@\\
\mbox{}\verb@        yfs.extend([site[1], pt[1]])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "\n----------"@\\
\mbox{}\verb@    print "Horse Tour"@\\
\mbox{}\verb@    print "-----------"@\\
\mbox{}\verb@    waiting_times = [0.0] + horseflytour['horse_waiting_times'].tolist() # the waiting time at the starting point is 0@\\
\mbox{}\verb@    #print waiting_times@\\
\mbox{}\verb@    for pt, time in zip(zip(xhs,yhs), waiting_times) :@\\
\mbox{}\verb@        print pt, Fore.GREEN, " ---> Horse Waited ", time, Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "\n----------"@\\
\mbox{}\verb@    print "Fly Tour"@\\
\mbox{}\verb@    print "----------"@\\
\mbox{}\verb@    for item, i in zip(zip(xfs,yfs), range(len(xfs))):@\\
\mbox{}\verb@        if i%2 == 0:@\\
\mbox{}\verb@           print item@\\
\mbox{}\verb@        else :@\\
\mbox{}\verb@           print Fore.RED + str(item) + "----> Site" +  Style.RESET_ALL@\\
\mbox{}\verb@@\\
\mbox{}\verb@    print "----------------------------------"@\\
\mbox{}\verb@    print Fore.GREEN, "\nSpeed of the drone was set to be", phi@\\
\mbox{}\verb@    #tour_length = utils_algo.length_polygonal_chain( zip(xhs, yhs))@\\
\mbox{}\verb@    tour_length = horseflytour['tour_length_with_waiting_time_included']@\\
\mbox{}\verb@    print "Tour length of the horse is ",  tour_length@\\
\mbox{}\verb@    print "Algorithm code-Key used "    , algo_str, Style.RESET_ALL@\\
\mbox{}\verb@    print "----------------------------------\n"@\\
\mbox{}\verb@           @\\
\mbox{}\verb@    #kwargs = {'size':'large'}@\\
\mbox{}\verb@    for x,y,i in zip(xsites, ysites, range(len(xsites))):@\\
\mbox{}\verb@          ax.text(x, y, str(i+1), bbox=dict(facecolor='#ddcba0', alpha=1.0)) @\\
\mbox{}\verb@    ax.plot(xfs,yfs,'g-') # fly tour is green@\\
\mbox{}\verb@    ax.plot(xhs, yhs, color=tour_color, marker='s', linewidth=3.0) # horse is red@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Initial position of horse and fly@\\
\mbox{}\verb@    ax.add_patch( mpl.patches.Circle( horseflyinit,@\\
\mbox{}\verb@                                      radius = 1/34.0,@\\
\mbox{}\verb@                                      facecolor= '#D13131', #'red',@\\
\mbox{}\verb@                                      edgecolor='black'   )  )@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    fontsize = 20@\\
\mbox{}\verb@    tnrfont = {'fontname':'Times New Roman'}@\\
\mbox{}\verb@    ax.set_title( r'Algorithm Used: ' + algo_str +  '\nTour Length: ' \@\\
\mbox{}\verb@                    + str(tour_length)[:7], fontdict={'fontsize':fontsize}, **tnrfont)@\\
\mbox{}\verb@    ax.set_xlabel(r'Number of sites: ' + str(len(xsites)) + '\nDrone Speed: ' + str(phi) ,@\\
\mbox{}\verb@                  fontdict={'fontsize':fontsize}, **tnrfont)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@plotTour@\nobreak\ \NWlink{nuweb22c}{22c}.\item \NWtxtIdentsUsed\nobreak\  \verb@tour_length@\nobreak\ \NWlink{nuweb44a}{44a}, \verb@tour_length_with_waiting_time_included@\nobreak\ \NWlink{nuweb44b}{44b}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
\section{Animation routines}

\newchunk 

After writing out the schedule, it would be nice to have a function that animates the 
delivery process of the schedule. Every problem will have animation features unique to
its features. Any abstraction will reveal itself only after I design the various
algorithms and extract the various features. 

In general, all algorithms for a problem will write out a YAML file containing the schedule 
in the outputted run-folder. To animate a schedule and write the resulting movie to disk
we just pass the name of the file containing the schedule. Since the output file-format
of the schedule is identical for all algorithms of a problem, it is sufficient to have
just one animation function. 

Schedules will typically be animated iff there is a \verb|animate_schedule_p| boolean 
flag set to \verb|True| in the arguments of every algorithm's function. 

{\color{red} TODO!! write horsewaiting and drone waiting times to disk too! and incorporate
it into the animation. } 

Here we render the Horse and Fly moving according to their 
assigned tours at their respective speeds, we don't 
need to ``coordinate'' the plotting since that has already 
been done by the scheudle itself. 
    
A site that has been unserviced is represented by a blue dot. 
A site that has been serviced is represented by a pink dot. 
As more and more sites get serviced you should gradually see a pinkening 
of the sites. 
   
At the top of the plot, start a countdown timer of the number 
sites remaining to be serviced. This gives the count of blue dots. 
give the speed ratio as the X-title. Later when waiting times are
incorprated give the time-till liftoff counter too maybe??!!

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap56}\raggedright\small
\NWtarget{nuweb47a}{} $\langle\,${\itshape Animation routines for classic horsefly}\nobreak\ {\footnotesize {47a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def animateSchedule(schedule_file_name):@\\
\mbox{}\verb@      import yaml@\\
\mbox{}\verb@      import numpy as np@\\
\mbox{}\verb@@\\
\mbox{}\verb@      with open(schedule_file_name, 'r') as stream:@\\
\mbox{}\verb@            schedule = yaml.load(stream)@\\
\mbox{}\verb@@\\
\mbox{}\verb@      phi           = float(schedule['phi'])@\\
\mbox{}\verb@      inithorseposn = schedule['inithorseposn']@\\
\mbox{}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Get legs of the horse and fly tours}\nobreak\ {\footnotesize \NWlink{nuweb47b}{47b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      @\hbox{$\langle\,${\itshape Initialize the movie}\nobreak\ {\footnotesize \NWlink{nuweb47c}{47c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@      for horse_leg, \@\\
\mbox{}\verb@          fly_leg,   \@\\
\mbox{}\verb@          leg_idx in zip(horse_legs, \@\\
\mbox{}\verb@                         fly_legs,   \@\\
\mbox{}\verb@                         range(len(horse_legs))):@\\
\mbox{}\verb@@\\
\mbox{}\verb@           @\hbox{$\langle\,${\itshape Discretize this iteration's horse leg and fly leg}\nobreak\ {\footnotesize \NWlink{nuweb48a}{48a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           @\hbox{$\langle\,${\itshape Locate the position of site in \verb|fly_leg|}\nobreak\ {\footnotesize \NWlink{nuweb48b}{48b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           #for horse_posn, fly_posn, in zip(horse_posns, fly_posns) :@\\
\mbox{}\verb@           #      @\hbox{$\langle\,${\itshape Render frame and add to animation registry}\nobreak\ {\footnotesize \NWlink{nuweb48c}{48c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@           #      @\hbox{$\langle\,${\itshape Render visited and unvisited sites}\nobreak\ {\footnotesize \NWlink{nuweb48d}{48d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      #@\hbox{$\langle\,${\itshape Write animation of schedule to disk}\nobreak\ {\footnotesize \NWlink{nuweb48e}{48e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@      sys.exit()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.
\item \NWtxtIdentsUsed\nobreak\  \verb@fly_legs,@\nobreak\ \NWlink{nuweb47b}{47b}, \verb@horse_legs,@\nobreak\ \NWlink{nuweb47b}{47b}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm} \newchunk
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap57}\raggedright\small
\NWtarget{nuweb47b}{} $\langle\,${\itshape Get legs of the horse and fly tours}\nobreak\ {\footnotesize {47b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@horse_tour  = map(np.asarray, schedule['horse_tour']   )@\\
\mbox{}\verb@sites         = map(np.asarray, schedule['visited_sites'])@\\
\mbox{}\verb@     @\\
\mbox{}\verb@xhs = [ horse_tour[i][0] for i in range(len(horse_tour))]    @\\
\mbox{}\verb@yhs = [ horse_tour[i][1] for i in range(len(horse_tour))]    @\\
\mbox{}\verb@xfs , yfs = [xhs[0]], [yhs[0]]@\\
\mbox{}\verb@for site, pt in zip (sites,horse_tour[1:]):@\\
\mbox{}\verb@         xfs.extend([site[0], pt[0]])@\\
\mbox{}\verb@         yfs.extend([site[1], pt[1]])@\\
\mbox{}\verb@fly_tour = map(np.asarray,zip(xfs,yfs))@\\
\mbox{}\verb@@\\
\mbox{}\verb@horse_legs = zip(horse_tour, horse_tour[1:])@\\
\mbox{}\verb@fly_legs   = zip(fly_tour, fly_tour[1:], fly_tour[2:]) [0::2]@\\
\mbox{}\verb@@\\
\mbox{}\verb@assert(len(horse_legs) == len(fly_legs))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.
\item \NWtxtIdentsDefed\nobreak\  \verb@fly_legs,@\nobreak\ \NWlink{nuweb47a}{47a}, \verb@fly_tour,@\nobreak\ \NWtxtIdentsNotUsed, \verb@horse_legs,@\nobreak\ \NWlink{nuweb47a}{47a}, \verb@horse_tour@\nobreak\ \NWlink{nuweb35a}{35a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb38a}{, 38a}\NWlink{nuweb39b}{, 39b}\NWlink{nuweb41a}{, 41a}\NWlink{nuweb43}{, 43}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm} \newchunk
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap58}\raggedright\small
\NWtarget{nuweb47c}{} $\langle\,${\itshape Initialize the movie}\nobreak\ {\footnotesize {47c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@pass@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm} \newchunk On each of the legs of the horse and fly, 
we place a dense sequence of points, based on their respective speeds. 
By ``subleg'', I refer to this collection of points placed along a leg. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap59}\raggedright\small
\NWtarget{nuweb48a}{} $\langle\,${\itshape Discretize this iteration's horse leg and fly leg}\nobreak\ {\footnotesize {48a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def discretize_leg(pts,speed):@\\
\mbox{}\verb@     subleg_pts = []@\\
\mbox{}\verb@     numpts     = len(pts)@\\
\mbox{}\verb@     k          = 3 # the higher, the speed, the fewer the points. tentatively (40/floor(speed))@\\
\mbox{}\verb@     for p,q in zip(pts, pts[1:]):@\\
\mbox{}\verb@          tmp = []@\\
\mbox{}\verb@          for t in np.linspace(0,1,k): ### 10 should be replaced by an appropriate constant@\\
\mbox{}\verb@              tmp.append( (1-t)*p + t*q ) @\\
\mbox{}\verb@          subleg_pts.extend(tmp[:-1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@     subleg_pts.append(pts[-1])@\\
\mbox{}\verb@     return subleg_pts@\\
\mbox{}\verb@@\\
\mbox{}\verb@horse_posns = discretize_leg(horse_leg,1.0)@\\
\mbox{}\verb@fly_posns   = discretize_leg(fly_leg  ,phi)@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm} \newchunk
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap60}\raggedright\small
\NWtarget{nuweb48b}{} $\langle\,${\itshape Locate the position of site in \verb|fly_leg|}\nobreak\ {\footnotesize {48b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@pass@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk
Render the frame. This means all the points along 
horse-leg from 0 till \verb|leg_idx| and then upto 
\verb|subleg_idx| gets rendered. Since the rendering 
happens in memory and not as a write to disk, this 
should get rendered quickly. 

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap61}\raggedright\small
\NWtarget{nuweb48c}{} $\langle\,${\itshape Render frame and add to animation registry}\nobreak\ {\footnotesize {48c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@# pass@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace{-0.8cm}\newchunk 
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap62}\raggedright\small
\NWtarget{nuweb48d}{} $\langle\,${\itshape Render visited and unvisited sites}\nobreak\ {\footnotesize {48d}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@   @\\
\mbox{}\verb@#if subleg_idx == site_loc:@\\
\mbox{}\verb@#   render as blue@\\
\mbox{}\verb@#else @\\
\mbox{}\verb@#   render sites as pink whatever. @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap63}\raggedright\small
\NWtarget{nuweb48e}{} $\langle\,${\itshape Write animation of schedule to disk}\nobreak\ {\footnotesize {48e}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@pass@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb47a}{47a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Chapter Index of Fragments}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item $\langle\,$Algorithms for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb27}{27}\NWlink{nuweb28}{, 28}\NWlink{nuweb29}{, 29}\NWlink{nuweb33a}{, 33a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Animation routines for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb47a}{47a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Clear canvas and states of all objects\nobreak\ {\footnotesize \NWlink{nuweb24b}{24b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb22b}{22b}.}
\item $\langle\,$Compute the length of the tour that currently services the visited sites\nobreak\ {\footnotesize \NWlink{nuweb41c}{41c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41b}{41b}.}
\item $\langle\,$Define auxiliary helper functions\nobreak\ {\footnotesize \NWlink{nuweb39c}{39c}\NWlink{nuweb40a}{, 40a}\NWlink{nuweb40b}{b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Define key-press handler\nobreak\ {\footnotesize \NWlink{nuweb22b}{22b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Define various insertion policy classes\nobreak\ {\footnotesize \NWlink{nuweb41a}{41a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Discretize this iteration's horse leg and fly leg\nobreak\ {\footnotesize \NWlink{nuweb48a}{48a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Draw horse and fly-tours\nobreak\ {\footnotesize \NWlink{nuweb37a}{37a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Draw unvisited sites as filled blue circles\nobreak\ {\footnotesize \NWlink{nuweb37c}{37c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Extract $x$ and $y$ coordinates of the points on the horse, fly tours, visited and unvisited sites\nobreak\ {\footnotesize \NWlink{nuweb36a}{36a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Find the unvisited site which on insertion increases tour-length by the least amount\nobreak\ {\footnotesize \NWlink{nuweb42c}{42c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41b}{41b}.}
\item $\langle\,$Generate a bunch of uniform or non-uniform random points on the canvas\nobreak\ {\footnotesize \NWlink{nuweb24a}{24a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb22b}{22b}.}
\item $\langle\,$Get legs of the horse and fly tours\nobreak\ {\footnotesize \NWlink{nuweb47b}{47b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Give metainformation about current picture as headers and footers\nobreak\ {\footnotesize \NWlink{nuweb37d}{37d}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$If \texttt{self.sites[u]} is chosen for insertion, find best insertion position and update \texttt{delta\_increase\_least\_table}\nobreak\ {\footnotesize \NWlink{nuweb42b}{42b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41b}{41b}.}
\item $\langle\,$Initialize the movie\nobreak\ {\footnotesize \NWlink{nuweb47c}{47c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Local data-structures for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb25b}{25b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Local utility functions for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb44a}{44a}\NWlink{nuweb44b}{b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Locate the position of site in \verb|fly_leg|\nobreak\ {\footnotesize \NWlink{nuweb48b}{48b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Make an animation of algorithm states, if \verb|write_algo_states_to_disk_p == True|\nobreak\ {\footnotesize \NWlink{nuweb38b}{38b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Make an animation of the schedule, if \verb|animate_schedule_p == True|\nobreak\ {\footnotesize \NWlink{nuweb39a}{39a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Mark initial position of horse and fly boldly on canvas\nobreak\ {\footnotesize \NWlink{nuweb36b}{36b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Methods for \verb|PolicyBestInsertionNaive|\nobreak\ {\footnotesize \NWlink{nuweb41b}{41b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41a}{41a}.}
\item $\langle\,$Place numbered markers on visited sites to mark the order of visitation explicitly\nobreak\ {\footnotesize \NWlink{nuweb37b}{37b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Plotting routines for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb45}{45}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Relevant imports for classic horsefly\nobreak\ {\footnotesize \NWlink{nuweb21b}{21b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Render current algorithm state to image file\nobreak\ {\footnotesize \NWlink{nuweb35b}{35b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35a}{35a}.}
\item $\langle\,$Render frame and add to animation registry\nobreak\ {\footnotesize \NWlink{nuweb48c}{48c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Render visited and unvisited sites\nobreak\ {\footnotesize \NWlink{nuweb48d}{48d}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Return horsefly tour, along with additional information\nobreak\ {\footnotesize \NWlink{nuweb39b}{39b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Set insertion policy class for current run\nobreak\ {\footnotesize \NWlink{nuweb34a}{34a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Set log, algo-state and input-output files config\nobreak\ {\footnotesize \NWlink{nuweb33b}{33b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Set up interactive canvas\nobreak\ {\footnotesize \NWlink{nuweb25a}{25a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Set up logging information relevant to this module\nobreak\ {\footnotesize \NWlink{nuweb22a}{22a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb21a}{21a}.}
\item $\langle\,$Set up plotting area and canvas, fig, ax, and other configs\nobreak\ {\footnotesize \NWlink{nuweb35c}{35c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Set up tracking variables local to this iteration\nobreak\ {\footnotesize \NWlink{nuweb42a}{42a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41b}{41b}.}
\item $\langle\,$Start entering input from the command-line\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb22b}{22b}.}
\item $\langle\,$Update states for \texttt{PolicyBestInsertionNaive}\nobreak\ {\footnotesize \NWlink{nuweb43}{43}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb41b}{41b}.}
\item $\langle\,$Use insertion policy to find the cheapest site to insert into current tour\nobreak\ {\footnotesize \NWlink{nuweb34b}{34b}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Write algorithm's current state to file\nobreak\ {\footnotesize \NWlink{nuweb35a}{35a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\item $\langle\,$Write animation of schedule to disk\nobreak\ {\footnotesize \NWlink{nuweb48e}{48e}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb47a}{47a}.}
\item $\langle\,$Write image file\nobreak\ {\footnotesize \NWlink{nuweb37e}{37e}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb35b}{35b}.}
\item $\langle\,$Write input and output to file\nobreak\ {\footnotesize \NWlink{nuweb38a}{38a}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb33a}{33a}.}
\end{list}}
\section{Chapter Index of Identifiers}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \verb@algo_exact_given_specific_ordering@: \NWlink{nuweb22c}{22c}\NWlink{nuweb27}{, 27}\NWlink{nuweb28}{, 28}, \underline{\NWlink{nuweb29}{29}}.
\item \verb@algo_greedy_incremental_insertion,@: \NWlink{nuweb22c}{22c}, \underline{\NWlink{nuweb33a}{33a}}.
\item \verb@compute_collinear_horseflies_tour@: \underline{\NWlink{nuweb40b}{40b}}\NWlink{nuweb43}{, 43}.
\item \verb@compute_collinear_horseflies_tour_length@: \underline{\NWlink{nuweb40a}{40a}}\NWlink{nuweb41c}{, 41c}\NWlink{nuweb42b}{, 42b}.
\item \verb@current_tour_length@: \underline{\NWlink{nuweb41c}{41c}}\NWlink{nuweb42b}{, 42b}.
\item \verb@delta_increase_least@: \underline{\NWlink{nuweb42a}{42a}}\NWlink{nuweb42b}{, 42b}.
\item \verb@delta_increase_least_table@: \underline{\NWlink{nuweb41b}{41b}}\NWlink{nuweb42b}{, 42b}\NWlink{nuweb42c}{c}.
\item \verb@fly_legs,@: \NWlink{nuweb47a}{47a}, \underline{\NWlink{nuweb47b}{47b}}.
\item \verb@fly_tour,@: \underline{\NWlink{nuweb47b}{47b}}.
\item \verb@HorseFlyInput@: \NWlink{nuweb25a}{25a}, \underline{\NWlink{nuweb25b}{25b}}.
\item \verb@horse_legs,@: \NWlink{nuweb47a}{47a}, \underline{\NWlink{nuweb47b}{47b}}.
\item \verb@horse_tour@: \NWlink{nuweb35a}{35a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb38a}{, 38a}\NWlink{nuweb39b}{, 39b}\NWlink{nuweb41a}{, 41a}\NWlink{nuweb43}{, 43}, \underline{\NWlink{nuweb47b}{47b}}.
\item \verb@ibest,@: \underline{\NWlink{nuweb42a}{42a}}\NWlink{nuweb42b}{, 42b}.
\item \verb@io_file_name,@: \underline{\NWlink{nuweb33b}{33b}}\NWlink{nuweb38a}{, 38a}.
\item \verb@logger@: \NWlink{nuweb22a}{22a}, \underline{\NWlink{nuweb33b}{33b}}.
\item \verb@plotTour@: \NWlink{nuweb22c}{22c}, \underline{\NWlink{nuweb45}{45}}.
\item \verb@self.horse_tour@: \underline{\NWlink{nuweb41a}{41a}}\NWlink{nuweb43}{, 43}.
\item \verb@self.inithorseposn,@: \NWlink{nuweb25b}{25b}, \underline{\NWlink{nuweb41a}{41a}}\NWlink{nuweb41c}{, 41c}\NWlink{nuweb42b}{, 42b}\NWlink{nuweb43}{, 43}.
\item \verb@self.sites,@: \NWlink{nuweb25b}{25b}, \underline{\NWlink{nuweb41a}{41a}}.
\item \verb@self.visited_sites,@: \underline{\NWlink{nuweb41a}{41a}}\NWlink{nuweb41c}{, 41c}\NWlink{nuweb43}{, 43}.
\item \verb@single_site_solution@: \underline{\NWlink{nuweb39c}{39c}}\NWlink{nuweb40a}{, 40a}\NWlink{nuweb40b}{b}.
\item \verb@tour_length@: \NWlink{nuweb27}{27}\NWlink{nuweb29}{, 29}, \underline{\NWlink{nuweb44a}{44a}}\NWlink{nuweb45}{, 45}.
\item \verb@tour_length_with_waiting_time_included@: \NWlink{nuweb29}{29}\NWlink{nuweb39b}{, 39b}, \underline{\NWlink{nuweb44b}{44b}}\NWlink{nuweb45}{, 45}.
\item \verb@wrapperkeyPressHandler@: \underline{\NWlink{nuweb22b}{22b}}\NWlink{nuweb25a}{, 25a}.
\item \verb@write_algo_states_to_disk_p@: \underline{\NWlink{nuweb33a}{33a}}\NWlink{nuweb35a}{, 35a}\NWlink{nuweb35b}{b}\NWlink{nuweb38b}{, 38b}.
\end{list}} 

%------------------------------------------------------

%------------------------------------------------------\chapter{Segment Horsefly}
\label{chap:segment-horsefly}\chapter{Fixed Route Horsefly}
\label{chap:fixed-route-horsefly}\chapter{One Horse, Two Flies}
\label{chap:one-horse-two-flies}
\chapter{Reverse Horsefly}
\label{chap:reverse-horsefly}\chapter{Watchman Horsefly}
\label{watchman-horsefly}

\begin{appendices}
\chapter{Index of Files}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \verb@"../main.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb12a}{12a}.}
\item \verb@"../src/lib/problem_classic_horsefly.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb21a}{21a}.}
\item \verb@"../src/lib/utils_algo.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb17a}{17a}\NWlink{nuweb17b}{b}\NWlink{nuweb18a}{, 18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}.
}
\item \verb@"../src/lib/utils_graphics.py"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb14}{14}\NWlink{nuweb15a}{, 15a}\NWlink{nuweb15b}{b}\NWlink{nuweb16}{, 16}.
}
\end{list}}
\chapter{Man-page for \texttt{main.py}}

\listoftodos[Bucketlist of TODOS]

\end{appendices}

\end{document}
